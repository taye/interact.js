{
	"version": 3,
	"sources": [
		"interactStatic.ts"
	],
	"names": [
		"browser",
		"domUtils",
		"is",
		"pointerUtils",
		"isNonNativeEvent",
		"createInteractStatic",
		"scope",
		"interact",
		"target",
		"options",
		"interactable",
		"interactables",
		"get",
		"new",
		"events",
		"global",
		"globalEvents",
		"getPointerAverage",
		"pointerAverage",
		"getTouchBBox",
		"touchBBox",
		"getTouchDistance",
		"touchDistance",
		"getTouchAngle",
		"touchAngle",
		"getElementRect",
		"getElementClientRect",
		"matchesSelector",
		"closest",
		"version",
		"use",
		"plugin",
		"this",
		"usePlugin",
		"isSet",
		"context",
		"on",
		"type",
		"listener",
		"string",
		"search",
		"trim",
		"split",
		"array",
		"eventType",
		"object",
		"prop",
		"actions",
		"push",
		"add",
		"document",
		"off",
		"index",
		"indexOf",
		"splice",
		"remove",
		"debug",
		"supportsTouch",
		"supportsPointerEvent",
		"stop",
		"interaction",
		"interactions",
		"list",
		"pointerMoveTolerance",
		"newValue",
		"number",
		"addDocument",
		"doc",
		"removeDocument"
	],
	"mappings": "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",
	"sourcesContent": [
		"/** @module interact */\nimport * as Interact from '@interactjs/types/index'\nimport browser from '@interactjs/utils/browser'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport { Interactable } from './Interactable'\nimport { Options } from './defaultOptions'\nimport isNonNativeEvent from './isNonNativeEvent'\n\nexport interface InteractStatic {\n  (target: Interact.Target, options?: Options): Interactable\n  getPointerAverage: typeof pointerUtils.pointerAverage\n  getTouchBBox: typeof pointerUtils.touchBBox\n  getTouchDistance: typeof pointerUtils.touchDistance\n  getTouchAngle: typeof pointerUtils.touchAngle\n  getElementRect: typeof domUtils.getElementRect\n  getElementClientRect: typeof domUtils.getElementClientRect\n  matchesSelector: typeof domUtils.matchesSelector\n  closest: typeof domUtils.closest\n  /** @internal */ globalEvents: any\n  version: string\n  /** @internal */ scope: Interact.Scope\n  use(plugin: Interact.Plugin, options?: {\n    [key: string]: any\n  }): any\n  isSet(target: Interact.Element, options?: any): boolean\n  on(type: string | Interact.EventTypes, listener: Interact.ListenersArg, options?: object): any\n  off(type: Interact.EventTypes, listener: any, options?: object): any\n  debug(): any\n  supportsTouch(): boolean\n  supportsPointerEvent(): boolean\n  stop(): any\n  pointerMoveTolerance(newValue?: number): any\n  addDocument(doc: Document, options?: object): void\n  removeDocument(doc: Document): void\n}\n\nexport function createInteractStatic (scope: Interact.Scope): Interact.InteractStatic {\n  /**\n   * ```js\n   * interact('#draggable').draggable(true)\n   *\n   * var rectables = interact('rect')\n   * rectables\n   *   .gesturable(true)\n   *   .on('gesturemove', function (event) {\n   *       // ...\n   *   })\n   * ```\n   *\n   * The methods of this variable can be used to set elements as interactables\n   * and also to change various default settings.\n   *\n   * Calling it as a function and passing an element or a valid CSS selector\n   * string returns an Interactable object which has various methods to configure\n   * it.\n   *\n   * @global\n   *\n   * @param {Element | string} target The HTML or SVG Element to interact with\n   * or CSS selector\n   * @return {Interactable}\n   */\n  const interact = ((target, options) => {\n    let interactable = scope.interactables.get(target, options)\n\n    if (!interactable) {\n      interactable = scope.interactables.new(target, options)\n      interactable.events.global = interact.globalEvents\n    }\n\n    return interactable\n  }) as InteractStatic\n\n  // expose the functions used to calculate multi-touch properties\n  interact.getPointerAverage = pointerUtils.pointerAverage\n  interact.getTouchBBox = pointerUtils.touchBBox\n  interact.getTouchDistance = pointerUtils.touchDistance\n  interact.getTouchAngle = pointerUtils.touchAngle\n\n  interact.getElementRect = domUtils.getElementRect\n  interact.getElementClientRect = domUtils.getElementClientRect\n  interact.matchesSelector = domUtils.matchesSelector\n  interact.closest = domUtils.closest\n\n  interact.globalEvents = {} as any\n\n  // eslint-disable-next-line no-undef\n  interact.version = process.env.npm_package_version\n  interact.scope = scope\n  /**\n  * Use a plugin\n  *\n  * @alias module:interact.use\n  *\n  * @param {Object} plugin\n  * @param {function} plugin.install\n  * @return {Interact.InteractStatic}\n   */\n  interact.use = function (plugin, options) {\n    this.scope.usePlugin(plugin, options)\n\n    return this\n  }\n\n  /**\n   * Check if an element or selector has been set with the {@link interact}\n   * function\n   *\n   * @alias module:interact.isSet\n   *\n   * @param {Element} element The Element being searched for\n   * @return {boolean} Indicates if the element or CSS selector was previously\n   * passed to interact\n   */\n  interact.isSet = function (target, options) {\n    return !!this.scope.interactables.get(target, options && options.context)\n  }\n\n  /**\n   * Add a global listener for an InteractEvent or adds a DOM event to `document`\n   *\n   * @alias module:interact.on\n   *\n   * @param {string | array | object} type The types of events to listen for\n   * @param {function} listener The function event (s)\n   * @param {object | boolean} [options] object or useCapture flag for\n   * addEventListener\n   * @return {object} interact\n   */\n  interact.on = function (type: string | Interact.EventTypes, listener: Interact.ListenersArg, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of (type as any[])) {\n        this.on(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.on(prop, (type as any)[prop], listener)\n      }\n\n      return this\n    }\n\n    // if it is an InteractEvent type, add listener to globalEvents\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      // if this type of event was never bound\n      if (!this.globalEvents[type]) {\n        this.globalEvents[type] = [listener]\n      }\n      else {\n        this.globalEvents[type].push(listener)\n      }\n    }\n    // If non InteractEvent type, addEventListener to document\n    else {\n      this.scope.events.add(this.scope.document, type, listener as Interact.Listener, { options })\n    }\n\n    return this\n  }\n\n  /**\n   * Removes a global InteractEvent listener or DOM event from `document`\n   *\n   * @alias module:interact.off\n   *\n   * @param {string | array | object} type The types of events that were listened\n   * for\n   * @param {function} listener The listener function to be removed\n   * @param {object | boolean} options [options] object or useCapture flag for\n   * removeEventListener\n   * @return {object} interact\n   */\n  interact.off = function (type: Interact.EventTypes, listener: any, options?: object) {\n    if (is.string(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/)\n    }\n\n    if (is.array(type)) {\n      for (const eventType of type) {\n        this.off(eventType, listener, options)\n      }\n\n      return this\n    }\n\n    if (is.object(type)) {\n      for (const prop in type) {\n        this.off(prop, type[prop], listener)\n      }\n\n      return this\n    }\n\n    if (isNonNativeEvent(type, this.scope.actions)) {\n      let index: number\n\n      if (type in this.globalEvents &&\n            (index = this.globalEvents[type].indexOf(listener)) !== -1) {\n        this.globalEvents[type].splice(index, 1)\n      }\n    }\n    else {\n      this.scope.events.remove(this.scope.document, type, listener, options)\n    }\n\n    return this\n  }\n\n  interact.debug = function () {\n    return this.scope\n  }\n\n  /**\n   * @alias module:interact.supportsTouch\n   *\n   * @return {boolean} Whether or not the browser supports touch input\n   */\n  interact.supportsTouch = function () {\n    return browser.supportsTouch\n  }\n\n  /**\n   * @alias module:interact.supportsPointerEvent\n   *\n   * @return {boolean} Whether or not the browser supports PointerEvents\n   */\n  interact.supportsPointerEvent = function () {\n    return browser.supportsPointerEvent\n  }\n\n  /**\n   * Cancels all interactions (end events are not fired)\n   *\n   * @alias module:interact.stop\n   *\n   * @return {object} interact\n   */\n  interact.stop = function () {\n    for (const interaction of this.scope.interactions.list) {\n      interaction.stop()\n    }\n\n    return this\n  }\n\n  /**\n   * Returns or sets the distance the pointer must be moved before an action\n   * sequence occurs. This also affects tolerance for tap events.\n   *\n   * @alias module:interact.pointerMoveTolerance\n   *\n   * @param {number} [newValue] The movement from the start position must be greater than this value\n   * @return {interact | number}\n   */\n  interact.pointerMoveTolerance = function (newValue?: number) {\n    if (is.number(newValue)) {\n      this.scope.interactions.pointerMoveTolerance = newValue\n\n      return this\n    }\n\n    return this.scope.interactions.pointerMoveTolerance\n  }\n\n  interact.addDocument = function (doc: Document, options?: object) {\n    this.scope.addDocument(doc, options)\n  }\n\n  interact.removeDocument = function (doc: Document) {\n    this.scope.removeDocument(doc)\n  }\n\n  return interact as any\n}\n"
	]
}