{
	"version": 3,
	"sources": [
		"Modification.ts"
	],
	"names": [
		"clone",
		"extend",
		"rectUtils",
		"Modification",
		"constructor",
		"interaction",
		"this",
		"states",
		"startOffset",
		"left",
		"right",
		"top",
		"bottom",
		"startDelta",
		"result",
		"endResult",
		"edges",
		"createResult",
		"start",
		"phase",
		"pageCoords",
		"modifierList",
		"actionOptions",
		"interactable",
		"options",
		"prepared",
		"name",
		"actionModifiers",
		"modifiers",
		"length",
		"filter",
		"modifier",
		"enabled",
		"map",
		"type",
		"methods",
		"_methods",
		"m",
		"getModifierList",
		"prepareStates",
		"getRectOffset",
		"rect",
		"x",
		"y",
		"arg",
		"preEnd",
		"startAll",
		"setAll",
		"fillArg",
		"element",
		"state",
		"skipModifiers",
		"unmodifiedRect",
		"coords",
		"slice",
		"newResult",
		"lastModifierCoords",
		"returnValue",
		"set",
		"shouldDo",
		"addEdges",
		"eventProps",
		"push",
		"delta",
		"rectDelta",
		"prevCoords",
		"prevRect",
		"rectChanged",
		"changed",
		"applyToInteraction",
		"curCoords",
		"cur",
		"startCoords",
		"curDelta",
		"coordsSet",
		"page",
		"client",
		"width",
		"height",
		"setAndApply",
		"modifiedCoords",
		"interacting",
		"adjustment",
		"beforeEnd",
		"event",
		"doPreend",
		"endPosition",
		"move",
		"stop",
		"modifierArg",
		"index",
		"restoreInteractionCoords",
		"modification",
		"coordsAndDeltas",
		"requireEndOnly",
		"endOnly",
		"setStart",
		"copyFrom",
		"other",
		"s",
		"destroy",
		"prop"
	],
	"mappings": "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",
	"sourcesContent": [
		"import { Modifier, ModifierArg, ModifierState } from './base'\nimport clone from '@interactjs/utils/clone'\nimport extend from '@interactjs/utils/extend'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nexport interface ModificationResult {\n  delta: Interact.Point\n  rectDelta: Interact.Rect\n  coords: Interact.Point\n  rect: Interact.FullRect\n  eventProps: any[]\n  changed: boolean\n}\n\ninterface MethodArg {\n  phase: Interact.EventPhase\n  pageCoords?: Interact.Point\n  rect?: Interact.FullRect\n  coords?: Interact.Point\n  preEnd?: boolean\n  skipModifiers?: number\n}\n\nexport default class Modification {\n  states: ModifierState[] = []\n  startOffset: Interact.Rect = { left: 0, right: 0, top: 0, bottom: 0 }\n  startDelta: Interact.Point = null\n  result?: ModificationResult = null\n  endResult?: Interact.Point = null\n  edges: Interact.EdgeOptions\n  readonly interaction: Readonly<Interact.Interaction>\n\n  constructor (interaction: Interact.Interaction) {\n    this.interaction = interaction\n    this.result = createResult()\n  }\n\n  start (\n    { phase }: MethodArg,\n    pageCoords: Interact.Point,\n  ) {\n    const { interaction } = this\n    const modifierList = getModifierList(interaction)\n    this.prepareStates(modifierList)\n\n    this.edges = extend({}, interaction.edges)\n    this.startOffset = getRectOffset(interaction.rect, pageCoords)\n    this.startDelta = { x: 0, y: 0 }\n\n    const arg: MethodArg = {\n      phase,\n      pageCoords,\n      preEnd: false,\n    }\n\n    this.result = createResult()\n    this.startAll(arg)\n\n    const result = this.result = this.setAll(arg)\n\n    return result\n  }\n\n  fillArg (arg: Partial<ModifierArg>) {\n    const { interaction } = this\n\n    arg.interaction = interaction\n    arg.interactable = interaction.interactable\n    arg.element = interaction.element\n    arg.rect = arg.rect || interaction.rect\n    arg.edges = this.edges\n    arg.startOffset = this.startOffset\n  }\n\n  startAll (arg: MethodArg & Partial<ModifierArg>) {\n    this.fillArg(arg)\n\n    for (const state of this.states) {\n      if (state.methods.start) {\n        arg.state = state\n        state.methods.start(arg as ModifierArg)\n      }\n    }\n  }\n\n  setAll (arg: MethodArg & Partial<ModifierArg>): ModificationResult {\n    this.fillArg(arg)\n\n    const {\n      phase,\n      preEnd,\n      skipModifiers,\n      rect: unmodifiedRect,\n    } = arg\n\n    arg.coords = extend({}, arg.pageCoords)\n    arg.rect = extend({}, unmodifiedRect)\n\n    const states = skipModifiers\n      ? this.states.slice(skipModifiers)\n      : this.states\n\n    const newResult = createResult(arg.coords, arg.rect)\n\n    for (const state of states) {\n      const { options } = state\n      const lastModifierCoords = extend({}, arg.coords)\n      let returnValue = null\n\n      if (state.methods.set && this.shouldDo(options, preEnd, phase)) {\n        arg.state = state\n        returnValue = state.methods.set(arg as ModifierArg)\n\n        rectUtils.addEdges(this.interaction.edges, arg.rect, { x: arg.coords.x - lastModifierCoords.x, y: arg.coords.y - lastModifierCoords.y })\n      }\n\n      newResult.eventProps.push(returnValue)\n    }\n\n    newResult.delta.x = arg.coords.x - arg.pageCoords.x\n    newResult.delta.y = arg.coords.y - arg.pageCoords.y\n\n    newResult.rectDelta.left   = arg.rect.left - unmodifiedRect.left\n    newResult.rectDelta.right  = arg.rect.right - unmodifiedRect.right\n    newResult.rectDelta.top    = arg.rect.top - unmodifiedRect.top\n    newResult.rectDelta.bottom = arg.rect.bottom - unmodifiedRect.bottom\n\n    const prevCoords = this.result.coords\n    const prevRect = this.result.rect\n\n    if (prevCoords && prevRect) {\n      const rectChanged = newResult.rect.left !== prevRect.left ||\n        newResult.rect.right !== prevRect.right ||\n        newResult.rect.top !== prevRect.top ||\n        newResult.rect.bottom !== prevRect.bottom\n\n      newResult.changed = rectChanged ||\n        prevCoords.x !== newResult.coords.x ||\n        prevCoords.y !== newResult.coords.y\n    }\n\n    return newResult\n  }\n\n  applyToInteraction (arg: { phase: Interact.EventPhase, rect?: Interact.Rect }) {\n    const { interaction } = this\n    const { phase } = arg\n    const curCoords = interaction.coords.cur\n    const startCoords = interaction.coords.start\n    const { result, startDelta } = this\n    const curDelta = result.delta\n\n    if (phase === 'start') {\n      extend(this.startDelta, result.delta)\n    }\n\n    for (const [coordsSet, delta] of [[startCoords, startDelta], [curCoords, curDelta]] as const) {\n      coordsSet.page.x   += delta.x\n      coordsSet.page.y   += delta.y\n      coordsSet.client.x += delta.x\n      coordsSet.client.y += delta.y\n    }\n\n    const { rectDelta } = this.result\n    const rect = arg.rect || interaction.rect\n\n    rect.left   += rectDelta.left\n    rect.right  += rectDelta.right\n    rect.top    += rectDelta.top\n    rect.bottom += rectDelta.bottom\n\n    rect.width = rect.right - rect.left\n    rect.height = rect.bottom - rect.top\n  }\n\n  setAndApply (arg: Partial<Interact.DoAnyPhaseArg> & {\n    phase: Interact.EventPhase\n    preEnd?: boolean\n    skipModifiers?: number\n    modifiedCoords?: Interact.Point\n  }): void | false {\n    const { interaction } = this\n    const { phase, preEnd, skipModifiers } = arg\n\n    const result = this.setAll({\n      preEnd,\n      phase,\n      pageCoords: arg.modifiedCoords || interaction.coords.cur.page,\n    })\n\n    this.result = result\n\n    // don't fire an action move if a modifier would keep the event in the same\n    // cordinates as before\n    if (!result.changed && (!skipModifiers || skipModifiers < this.states.length) && interaction.interacting()) {\n      return false\n    }\n\n    if (arg.modifiedCoords) {\n      const { page } = interaction.coords.cur\n      const adjustment = {\n        x: arg.modifiedCoords.x - page.x,\n        y: arg.modifiedCoords.y - page.y,\n      }\n\n      result.coords.x += adjustment.x\n      result.coords.y += adjustment.y\n      result.delta.x += adjustment.x\n      result.delta.y += adjustment.y\n    }\n\n    this.applyToInteraction(arg)\n  }\n\n  beforeEnd (arg: Omit<Interact.DoAnyPhaseArg, 'iEvent'> & { state?: ModifierState }): void | false {\n    const { interaction, event } = arg\n    const states = this.states\n\n    if (!states || !states.length) {\n      return\n    }\n\n    let doPreend = false\n\n    for (const state of states) {\n      arg.state = state\n      const { options, methods } = state\n\n      const endPosition = methods.beforeEnd && methods.beforeEnd(arg as unknown as ModifierArg)\n\n      if (endPosition) {\n        this.endResult = endPosition\n        return false\n      }\n\n      doPreend = doPreend || (!doPreend && this.shouldDo(options, true, arg.phase, true))\n    }\n\n    if (doPreend) {\n      // trigger a final modified move before ending\n      interaction.move({ event, preEnd: true })\n    }\n  }\n\n  stop (arg: { interaction: Interact.Interaction }) {\n    const { interaction } = arg\n\n    if (!this.states || !this.states.length) {\n      return\n    }\n\n    const modifierArg: Partial<ModifierArg> = extend({\n      states: this.states,\n      interactable: interaction.interactable,\n      element: interaction.element,\n      rect: null,\n    }, arg)\n\n    this.fillArg(modifierArg)\n\n    for (const state of this.states) {\n      modifierArg.state = state\n\n      if (state.methods.stop) { state.methods.stop(modifierArg as ModifierArg) }\n    }\n\n    this.states = null\n    this.endResult = null\n  }\n\n  prepareStates (modifierList: Modifier[]) {\n    this.states = []\n\n    for (let index = 0; index < modifierList.length; index++) {\n      const { options, methods, name } = modifierList[index]\n\n      if (options && options.enabled === false) { continue }\n\n      this.states.push({\n        options,\n        methods,\n        index,\n        name,\n      })\n    }\n\n    return this.states\n  }\n\n  restoreInteractionCoords ({ interaction: { coords, rect, modification } }: { interaction: Interact.Interaction }) {\n    if (!modification.result) { return }\n\n    const { startDelta } = modification\n    const { delta: curDelta, rectDelta } = modification.result\n\n    const coordsAndDeltas = [\n      [coords.start, startDelta],\n      [coords.cur, curDelta],\n    ]\n\n    for (const [coordsSet, delta] of coordsAndDeltas as any) {\n      coordsSet.page.x -= delta.x\n      coordsSet.page.y -= delta.y\n      coordsSet.client.x -= delta.x\n      coordsSet.client.y -= delta.y\n    }\n\n    rect.left -= rectDelta.left\n    rect.right -= rectDelta.right\n    rect.top -= rectDelta.top\n    rect.bottom -= rectDelta.bottom\n  }\n\n  shouldDo (options, preEnd?: boolean, phase?: string, requireEndOnly?: boolean) {\n    if (\n      // ignore disabled modifiers\n      (!options || options.enabled === false) ||\n      // check if we require endOnly option to fire move before end\n      (requireEndOnly && !options.endOnly) ||\n      // don't apply endOnly modifiers when not ending\n      (options.endOnly && !preEnd) ||\n      // check if modifier should run be applied on start\n      (phase === 'start' && !options.setStart)\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  copyFrom (other: Modification) {\n    this.startOffset = other.startOffset\n    this.startDelta = other.startDelta\n    this.edges = other.edges\n    this.states = other.states.map(s => clone(s) as ModifierState)\n    this.result = createResult(extend({}, other.result.coords), extend({}, other.result.rect))\n  }\n\n  destroy () {\n    for (const prop in this) {\n      this[prop] = null\n    }\n  }\n}\n\nfunction createResult (coords?: Interact.Point, rect?: Interact.FullRect): ModificationResult {\n  return {\n    rect,\n    coords,\n    delta: { x: 0, y: 0 },\n    rectDelta: {\n      left  : 0,\n      right : 0,\n      top   : 0,\n      bottom: 0,\n    },\n    eventProps: [],\n    changed: true,\n  }\n}\n\nfunction getModifierList (interaction) {\n  const actionOptions = interaction.interactable.options[interaction.prepared.name]\n  const actionModifiers = actionOptions.modifiers\n\n  if (actionModifiers && actionModifiers.length) {\n    return actionModifiers.filter(\n      modifier => !modifier.options || modifier.options.enabled !== false,\n    )\n  }\n\n  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize']\n    .map(type => {\n      const options = actionOptions[type]\n\n      return options && options.enabled && {\n        options,\n        methods: options._methods,\n      }\n    })\n    .filter(m => !!m)\n}\n\nexport function getRectOffset (rect, coords) {\n  return rect\n    ? {\n      left  : coords.x - rect.left,\n      top   : coords.y - rect.top,\n      right : rect.right  - coords.x,\n      bottom: rect.bottom - coords.y,\n    }\n    : {\n      left  : 0,\n      top   : 0,\n      right : 0,\n      bottom: 0,\n    }\n}\n"
	]
}