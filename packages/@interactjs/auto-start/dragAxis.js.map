{"version":3,"file":"dragAxis.js","sources":["dragAxis.ts"],"sourcesContent":["import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { SignalArgs, Scope } from '@interactjs/core/scope'\nimport type { ActionName, Element } from '@interactjs/core/types'\nimport { parentNode } from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\n\nimport autoStart from './base'\n\nfunction beforeStart({ interaction, eventTarget, dx, dy }: SignalArgs['interactions:move'], scope: Scope) {\n  if (interaction.prepared.name !== 'drag') return\n\n  // check if a drag is in the correct axis\n  const absX = Math.abs(dx)\n  const absY = Math.abs(dy)\n  const targetOptions = interaction.interactable.options.drag\n  const startAxis = targetOptions.startAxis\n  const currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy'\n\n  interaction.prepared.axis =\n    targetOptions.lockAxis === 'start'\n      ? (currentAxis[0] as 'x' | 'y') // always lock to one axis even if currentAxis === 'xy'\n      : targetOptions.lockAxis\n\n  // if the movement isn't in the startAxis of the interactable\n  if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {\n    // cancel the prepared action\n    ;(interaction as Interaction<ActionName>).prepared.name = null\n\n    // then try to get a drag from another ineractable\n    let element = eventTarget as Element\n\n    const getDraggable = function (interactable: Interactable): Interactable | void {\n      if (interactable === interaction.interactable) return\n\n      const options = interaction.interactable.options.drag\n\n      if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {\n        const action = interactable.getAction(\n          interaction.downPointer,\n          interaction.downEvent,\n          interaction,\n          element,\n        )\n\n        if (\n          action &&\n          action.name === 'drag' &&\n          checkStartAxis(currentAxis, interactable) &&\n          autoStart.validateAction(action, interactable, element, eventTarget, scope)\n        ) {\n          return interactable\n        }\n      }\n    }\n\n    // check all interactables\n    while (is.element(element)) {\n      const interactable = scope.interactables.forEachMatch(element, getDraggable)\n\n      if (interactable) {\n        ;(interaction as Interaction<ActionName>).prepared.name = 'drag'\n        interaction.interactable = interactable\n        interaction.element = element\n        break\n      }\n\n      element = parentNode(element) as Element\n    }\n  }\n}\n\nfunction checkStartAxis(startAxis: string, interactable: Interactable) {\n  if (!interactable) {\n    return false\n  }\n\n  const thisAxis = interactable.options.drag.startAxis\n\n  return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis\n}\n\nexport default {\n  id: 'auto-start/dragAxis',\n  listeners: { 'autoStart:before-start': beforeStart },\n}\n"],"names":["beforeStart","_ref","scope","interaction","eventTarget","dx","dy","prepared","name","absX","Math","abs","absY","targetOptions","interactable","options","drag","startAxis","currentAxis","axis","lockAxis","element","getDraggable","manualStart","testIgnoreAllow","action","getAction","downPointer","downEvent","checkStartAxis","autoStart","validateAction","is","interactables","forEachMatch","parentNode","thisAxis","id","listeners"],"mappings":"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"}