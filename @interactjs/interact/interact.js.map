{
	"version": 3,
	"sources": [
		"interact.ts"
	],
	"names": [
		"Scope",
		"browser",
		"events",
		"utils",
		"globalEvents",
		"scope",
		"interact",
		"target",
		"options",
		"interactable",
		"interactables",
		"get",
		"new",
		"global",
		"use",
		"plugin",
		"usePlugin",
		"isSet",
		"context",
		"on",
		"type",
		"listener",
		"is",
		"string",
		"search",
		"trim",
		"split",
		"array",
		"eventType",
		"object",
		"prop",
		"arr",
		"contains",
		"actions",
		"eventTypes",
		"push",
		"add",
		"document",
		"off",
		"remove",
		"index",
		"indexOf",
		"splice",
		"debug",
		"getPointerAverage",
		"pointer",
		"pointerAverage",
		"getTouchBBox",
		"touchBBox",
		"getTouchDistance",
		"touchDistance",
		"getTouchAngle",
		"touchAngle",
		"getElementRect",
		"dom",
		"getElementClientRect",
		"matchesSelector",
		"closest",
		"supportsTouch",
		"supportsPointerEvent",
		"stop",
		"interaction",
		"interactions",
		"list",
		"pointerMoveTolerance",
		"newValue",
		"number",
		"addListeners",
		"interacting",
		"_ending",
		"addDocument",
		"doc",
		"removeDocument"
	],
	"mappings": "AAAA;AAIA,SAASA,KAAT;AACA,OAAOC,OAAP;AACA,OAAOC,MAAP;AACA,OAAO,KAAKC,KAAZ;AAgCA,MAAMC,YAAiB,GAAG,EAA1B;AACA,MAAMC,KAAK,GAAG,IAAIL,KAAJ,EAAd;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAO,MAAMM,QAAwB,GAAG,SAASA,QAAT,CAAmBC,MAAnB,EAA4CC,OAA5C,EAA2D;AACjG,MAAIC,YAAY,GAAGJ,KAAK,CAACK,aAAN,CAAoBC,GAApB,CAAwBJ,MAAxB,EAAgCC,OAAhC,CAAnB;;AAEA,MAAI,CAACC,YAAL,EAAmB;AACjBA,IAAAA,YAAY,GAAGJ,KAAK,CAACK,aAAN,CAAoBE,GAApB,CAAwBL,MAAxB,EAAgCC,OAAhC,CAAf;AACAC,IAAAA,YAAY,CAACP,MAAb,CAAoBW,MAApB,GAA6BT,YAA7B;AACD;;AAED,SAAOK,YAAP;AACD,CATM;AAWP;;;;;;;;;;AASAH,QAAQ,CAACQ,GAAT,GAAeA,GAAf;;AACA,SAASA,GAAT,CAAcC,MAAd,EAAuCP,OAAvC,EAAyE;AACvEH,EAAAA,KAAK,CAACW,SAAN,CAAgBD,MAAhB,EAAwBP,OAAxB;AAEA,SAAOF,QAAP;AACD;AAED;;;;;;;;;;;;AAUAA,QAAQ,CAACW,KAAT,GAAiBA,KAAjB;;AACA,SAASA,KAAT,CAAgBV,MAAhB,EAA0CC,OAA1C,EAAyD;AACvD,SAAO,CAAC,CAACH,KAAK,CAACK,aAAN,CAAoBC,GAApB,CAAwBJ,MAAxB,EAAgCC,OAAO,IAAIA,OAAO,CAACU,OAAnD,CAAT;AACD;AAED;;;;;;;;;;;;;AAWAZ,QAAQ,CAACa,EAAT,GAAcA,EAAd;;AACA,SAASA,EAAT,CAAaC,IAAb,EAAiDC,QAAjD,EAAkFb,OAAlF,EAA4F;AAC1F,MAAIL,KAAK,CAACmB,EAAN,CAASC,MAAT,CAAgBH,IAAhB,KAAyBA,IAAI,CAACI,MAAL,CAAY,GAAZ,MAAqB,CAAC,CAAnD,EAAsD;AACpDJ,IAAAA,IAAI,GAAGA,IAAI,CAACK,IAAL,GAAYC,KAAZ,CAAkB,IAAlB,CAAP;AACD;;AAED,MAAIvB,KAAK,CAACmB,EAAN,CAASK,KAAT,CAAeP,IAAf,CAAJ,EAA0B;AACxB,SAAK,MAAMQ,SAAX,IAAyBR,IAAzB,EAAyC;AACvCd,MAAAA,QAAQ,CAACa,EAAT,CAAYS,SAAZ,EAAuBP,QAAvB,EAAiCb,OAAjC;AACD;;AAED,WAAOF,QAAP;AACD;;AAED,MAAIH,KAAK,CAACmB,EAAN,CAASO,MAAT,CAAgBT,IAAhB,CAAJ,EAA2B;AACzB,SAAK,MAAMU,IAAX,IAAmBV,IAAnB,EAAyB;AACvBd,MAAAA,QAAQ,CAACa,EAAT,CAAYW,IAAZ,EAAmBV,IAAD,CAA8BU,IAA9B,CAAlB,EAAuDT,QAAvD;AACD;;AAED,WAAOf,QAAP;AACD,GAnByF,CAqB1F;;;AACA,MAAIH,KAAK,CAAC4B,GAAN,CAAUC,QAAV,CAAmB3B,KAAK,CAAC4B,OAAN,CAAcC,UAAjC,EAA6Cd,IAA7C,CAAJ,EAAwD;AACtD;AACA,QAAI,CAAChB,YAAY,CAACgB,IAAD,CAAjB,EAAyB;AACvBhB,MAAAA,YAAY,CAACgB,IAAD,CAAZ,GAAqB,CAACC,QAAD,CAArB;AACD,KAFD,MAGK;AACHjB,MAAAA,YAAY,CAACgB,IAAD,CAAZ,CAAmBe,IAAnB,CAAwBd,QAAxB;AACD;AACF,GARD,CASA;AATA,OAUK;AACHnB,MAAAA,MAAM,CAACkC,GAAP,CAAW/B,KAAK,CAACgC,QAAjB,EAA2BjB,IAA3B,EAAiCC,QAAjC,EAAgE;AAAEb,QAAAA;AAAF,OAAhE;AACD;;AAED,SAAOF,QAAP;AACD;AAED;;;;;;;;;;;;;;AAYAA,QAAQ,CAACgC,GAAT,GAAeA,GAAf;;AACA,SAASA,GAAT,CAAclB,IAAd,EAAoBC,QAApB,EAA8Bb,OAA9B,EAAuC;AACrC,MAAIL,KAAK,CAACmB,EAAN,CAASC,MAAT,CAAgBH,IAAhB,KAAyBA,IAAI,CAACI,MAAL,CAAY,GAAZ,MAAqB,CAAC,CAAnD,EAAsD;AACpDJ,IAAAA,IAAI,GAAGA,IAAI,CAACK,IAAL,GAAYC,KAAZ,CAAkB,IAAlB,CAAP;AACD;;AAED,MAAIvB,KAAK,CAACmB,EAAN,CAASK,KAAT,CAAeP,IAAf,CAAJ,EAA0B;AACxB,SAAK,MAAMQ,SAAX,IAAwBR,IAAxB,EAA8B;AAC5Bd,MAAAA,QAAQ,CAACgC,GAAT,CAAaV,SAAb,EAAwBP,QAAxB,EAAkCb,OAAlC;AACD;;AAED,WAAOF,QAAP;AACD;;AAED,MAAIH,KAAK,CAACmB,EAAN,CAASO,MAAT,CAAgBT,IAAhB,CAAJ,EAA2B;AACzB,SAAK,MAAMU,IAAX,IAAmBV,IAAnB,EAAyB;AACvBd,MAAAA,QAAQ,CAACgC,GAAT,CAAaR,IAAb,EAAmBV,IAAI,CAACU,IAAD,CAAvB,EAA+BT,QAA/B;AACD;;AAED,WAAOf,QAAP;AACD;;AAED,MAAI,CAACH,KAAK,CAAC4B,GAAN,CAAUC,QAAV,CAAmB3B,KAAK,CAAC4B,OAAN,CAAcC,UAAjC,EAA6Cd,IAA7C,CAAL,EAAyD;AACvDlB,IAAAA,MAAM,CAACqC,MAAP,CAAclC,KAAK,CAACgC,QAApB,EAA8BjB,IAA9B,EAAoCC,QAApC,EAA8Cb,OAA9C;AACD,GAFD,MAGK;AACH,QAAIgC,KAAJ;;AAEA,QAAIpB,IAAI,IAAIhB,YAAR,IACA,CAACoC,KAAK,GAAGpC,YAAY,CAACgB,IAAD,CAAZ,CAAmBqB,OAAnB,CAA2BpB,QAA3B,CAAT,MAAmD,CAAC,CADxD,EAC2D;AACzDjB,MAAAA,YAAY,CAACgB,IAAD,CAAZ,CAAmBsB,MAAnB,CAA0BF,KAA1B,EAAiC,CAAjC;AACD;AACF;;AAED,SAAOlC,QAAP;AACD;;AAEDA,QAAQ,CAACqC,KAAT,GAAiBA,KAAjB;;AACA,SAASA,KAAT,GAAkB;AAChB,SAAOtC,KAAP;AACD,C,CAED;;;AACAC,QAAQ,CAACsC,iBAAT,GAA8BzC,KAAK,CAAC0C,OAAN,CAAcC,cAA5C;AACAxC,QAAQ,CAACyC,YAAT,GAA8B5C,KAAK,CAAC0C,OAAN,CAAcG,SAA5C;AACA1C,QAAQ,CAAC2C,gBAAT,GAA8B9C,KAAK,CAAC0C,OAAN,CAAcK,aAA5C;AACA5C,QAAQ,CAAC6C,aAAT,GAA8BhD,KAAK,CAAC0C,OAAN,CAAcO,UAA5C;AAEA9C,QAAQ,CAAC+C,cAAT,GAAgClD,KAAK,CAACmD,GAAN,CAAUD,cAA1C;AACA/C,QAAQ,CAACiD,oBAAT,GAAgCpD,KAAK,CAACmD,GAAN,CAAUC,oBAA1C;AACAjD,QAAQ,CAACkD,eAAT,GAAgCrD,KAAK,CAACmD,GAAN,CAAUE,eAA1C;AACAlD,QAAQ,CAACmD,OAAT,GAAgCtD,KAAK,CAACmD,GAAN,CAAUG,OAA1C;AAEA;;;;;;AAKAnD,QAAQ,CAACoD,aAAT,GAAyBA,aAAzB;;AACA,SAASA,aAAT,GAA0B;AACxB,SAAOzD,OAAO,CAACyD,aAAf;AACD;AAED;;;;;;;AAKApD,QAAQ,CAACqD,oBAAT,GAAgCA,oBAAhC;;AACA,SAASA,oBAAT,GAAiC;AAC/B,SAAO1D,OAAO,CAAC0D,oBAAf;AACD;AAED;;;;;;;;;AAOArD,QAAQ,CAACsD,IAAT,GAAgBA,IAAhB;;AACA,SAASA,IAAT,GAAiB;AACf,OAAK,MAAMC,WAAX,IAA0BxD,KAAK,CAACyD,YAAN,CAAmBC,IAA7C,EAAmD;AACjDF,IAAAA,WAAW,CAACD,IAAZ;AACD;;AAED,SAAOtD,QAAP;AACD;AAED;;;;;;;;;;;AASAA,QAAQ,CAAC0D,oBAAT,GAAgCA,oBAAhC;;AACA,SAASA,oBAAT,CAA+BC,QAA/B,EAAyC;AACvC,MAAI9D,KAAK,CAACmB,EAAN,CAAS4C,MAAT,CAAgBD,QAAhB,CAAJ,EAA+B;AAC7B5D,IAAAA,KAAK,CAACyD,YAAN,CAAmBE,oBAAnB,GAA0CC,QAA1C;AAEA,WAAO3D,QAAP;AACD;;AAED,SAAOD,KAAK,CAACyD,YAAN,CAAmBE,oBAA1B;AACD;;AAED3D,KAAK,CAAC8D,YAAN,CAAmB;AACjB,wBAAsB,CAAC;AAAE1D,IAAAA;AAAF,GAAD,KAAsB;AAC1CJ,IAAAA,KAAK,CAACK,aAAN,CAAoBqD,IAApB,CAAyBrB,MAAzB,CAAgCrC,KAAK,CAACK,aAAN,CAAoBqD,IAApB,CAAyBtB,OAAzB,CAAiChC,YAAjC,CAAhC,EAAgF,CAAhF,EAD0C,CAG1C;;AACA,SAAK,MAAMoD,WAAX,IAA0BxD,KAAK,CAACyD,YAAN,CAAmBC,IAA7C,EAAmD;AACjD,UAAIF,WAAW,CAACpD,YAAZ,KAA6BA,YAA7B,IAA6CoD,WAAW,CAACO,WAAZ,EAA7C,IAA0E,CAACP,WAAW,CAACQ,OAA3F,EAAoG;AAClGR,QAAAA,WAAW,CAACD,IAAZ;AACD;AACF;AACF;AAVgB,CAAnB;;AAaAtD,QAAQ,CAACgE,WAAT,GAAuB,CAACC,GAAD,EAAM/D,OAAN,KAAkBH,KAAK,CAACiE,WAAN,CAAkBC,GAAlB,EAAuB/D,OAAvB,CAAzC;;AACAF,QAAQ,CAACkE,cAAT,GAA0BD,GAAG,IAAIlE,KAAK,CAACmE,cAAN,CAAqBD,GAArB,CAAjC;;AAEAlE,KAAK,CAACC,QAAN,GAAiBA,QAAjB;AAEA,SAASD,KAAT;AACA,eAAeC,QAAf",
	"sourcesContent": [
		"/** @module interact */\n\nimport { Options } from '../core/defaultOptions'\nimport Interactable from '../core/Interactable'\nimport { Scope } from '../core/scope'\nimport browser from '../utils/browser'\nimport events from '../utils/events'\nimport * as utils from '../utils/index'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    interact: InteractStatic\n  }\n}\n\nexport interface InteractStatic {\n  (target: Interact.Target, options?: Options): Interactable\n  on: typeof on\n  pointerMoveTolerance: typeof pointerMoveTolerance\n  stop: typeof stop\n  supportsPointerEvent: typeof supportsPointerEvent\n  supportsTouch: typeof supportsTouch\n  debug: typeof debug\n  off: typeof off\n  isSet: typeof isSet\n  use: typeof use\n  getPointerAverage: typeof utils.pointer.pointerAverage\n  getTouchBBox: typeof utils.pointer.touchBBox\n  getTouchDistance: typeof utils.pointer.touchDistance\n  getTouchAngle: typeof utils.pointer.touchAngle\n  getElementRect: typeof utils.dom.getElementRect\n  getElementClientRect: typeof utils.dom.getElementClientRect\n  matchesSelector: typeof utils.dom.matchesSelector\n  closest: typeof utils.dom.closest\n  addDocument: typeof scope.addDocument\n  removeDocument: typeof scope.removeDocument\n  version: string\n}\n\nconst globalEvents: any = {}\nconst scope = new Scope()\n\n/**\n * ```js\n * interact('#draggable').draggable(true)\n *\n * var rectables = interact('rect')\n * rectables\n *   .gesturable(true)\n *   .on('gesturemove', function (event) {\n *       // ...\n *   })\n * ```\n *\n * The methods of this variable can be used to set elements as interactables\n * and also to change various default settings.\n *\n * Calling it as a function and passing an element or a valid CSS selector\n * string returns an Interactable object which has various methods to configure\n * it.\n *\n * @global\n *\n * @param {Element | string} target The HTML or SVG Element to interact with\n * or CSS selector\n * @return {Interactable}\n */\nexport const interact: InteractStatic = function interact (target: Interact.Target, options?: any) {\n  let interactable = scope.interactables.get(target, options)\n\n  if (!interactable) {\n    interactable = scope.interactables.new(target, options)\n    interactable.events.global = globalEvents\n  }\n\n  return interactable\n} as InteractStatic\n\n/**\n * Use a plugin\n *\n * @alias module:interact.use\n *\n * @param {Object} plugin\n * @param {function} plugin.install\n * @return {interact}\n */\ninteract.use = use\nfunction use (plugin: Interact.Plugin, options?: { [key: string]: any }) {\n  scope.usePlugin(plugin, options)\n\n  return interact\n}\n\n/**\n * Check if an element or selector has been set with the {@link interact}\n * function\n *\n * @alias module:interact.isSet\n *\n * @param {Element} element The Element being searched for\n * @return {boolean} Indicates if the element or CSS selector was previously\n * passed to interact\n */\ninteract.isSet = isSet\nfunction isSet (target: Interact.Element, options?: any) {\n  return !!scope.interactables.get(target, options && options.context)\n}\n\n/**\n * Add a global listener for an InteractEvent or adds a DOM event to `document`\n *\n * @alias module:interact.on\n *\n * @param {string | array | object} type The types of events to listen for\n * @param {function} listener The function event (s)\n * @param {object | boolean} [options] object or useCapture flag for\n * addEventListener\n * @return {object} interact\n */\ninteract.on = on\nfunction on (type: string | Interact.EventTypes, listener: Interact.ListenersArg, options?) {\n  if (utils.is.string(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/)\n  }\n\n  if (utils.is.array(type)) {\n    for (const eventType of (type as any[])) {\n      interact.on(eventType, listener, options)\n    }\n\n    return interact\n  }\n\n  if (utils.is.object(type)) {\n    for (const prop in type) {\n      interact.on(prop, (type as Interact.EventTypes)[prop], listener)\n    }\n\n    return interact\n  }\n\n  // if it is an InteractEvent type, add listener to globalEvents\n  if (utils.arr.contains(scope.actions.eventTypes, type)) {\n    // if this type of event was never bound\n    if (!globalEvents[type]) {\n      globalEvents[type] = [listener]\n    }\n    else {\n      globalEvents[type].push(listener)\n    }\n  }\n  // If non InteractEvent type, addEventListener to document\n  else {\n    events.add(scope.document, type, listener as Interact.Listener, { options })\n  }\n\n  return interact\n}\n\n/**\n * Removes a global InteractEvent listener or DOM event from `document`\n *\n * @alias module:interact.off\n *\n * @param {string | array | object} type The types of events that were listened\n * for\n * @param {function} listener The listener function to be removed\n * @param {object | boolean} options [options] object or useCapture flag for\n * removeEventListener\n * @return {object} interact\n */\ninteract.off = off\nfunction off (type, listener, options) {\n  if (utils.is.string(type) && type.search(' ') !== -1) {\n    type = type.trim().split(/ +/)\n  }\n\n  if (utils.is.array(type)) {\n    for (const eventType of type) {\n      interact.off(eventType, listener, options)\n    }\n\n    return interact\n  }\n\n  if (utils.is.object(type)) {\n    for (const prop in type) {\n      interact.off(prop, type[prop], listener)\n    }\n\n    return interact\n  }\n\n  if (!utils.arr.contains(scope.actions.eventTypes, type)) {\n    events.remove(scope.document, type, listener, options)\n  }\n  else {\n    let index\n\n    if (type in globalEvents &&\n        (index = globalEvents[type].indexOf(listener)) !== -1) {\n      globalEvents[type].splice(index, 1)\n    }\n  }\n\n  return interact\n}\n\ninteract.debug = debug\nfunction debug () {\n  return scope\n}\n\n// expose the functions used to calculate multi-touch properties\ninteract.getPointerAverage  = utils.pointer.pointerAverage\ninteract.getTouchBBox       = utils.pointer.touchBBox\ninteract.getTouchDistance   = utils.pointer.touchDistance\ninteract.getTouchAngle      = utils.pointer.touchAngle\n\ninteract.getElementRect       = utils.dom.getElementRect\ninteract.getElementClientRect = utils.dom.getElementClientRect\ninteract.matchesSelector      = utils.dom.matchesSelector\ninteract.closest              = utils.dom.closest\n\n/**\n * @alias module:interact.supportsTouch\n *\n * @return {boolean} Whether or not the browser supports touch input\n */\ninteract.supportsTouch = supportsTouch\nfunction supportsTouch () {\n  return browser.supportsTouch\n}\n\n/**\n * @alias module:interact.supportsPointerEvent\n *\n * @return {boolean} Whether or not the browser supports PointerEvents\n */\ninteract.supportsPointerEvent = supportsPointerEvent\nfunction supportsPointerEvent () {\n  return browser.supportsPointerEvent\n}\n\n/**\n * Cancels all interactions (end events are not fired)\n *\n * @alias module:interact.stop\n *\n * @return {object} interact\n */\ninteract.stop = stop\nfunction stop () {\n  for (const interaction of scope.interactions.list) {\n    interaction.stop()\n  }\n\n  return interact\n}\n\n/**\n * Returns or sets the distance the pointer must be moved before an action\n * sequence occurs. This also affects tolerance for tap events.\n *\n * @alias module:interact.pointerMoveTolerance\n *\n * @param {number} [newValue] The movement from the start position must be greater than this value\n * @return {interact | number}\n */\ninteract.pointerMoveTolerance = pointerMoveTolerance\nfunction pointerMoveTolerance (newValue) {\n  if (utils.is.number(newValue)) {\n    scope.interactions.pointerMoveTolerance = newValue\n\n    return interact\n  }\n\n  return scope.interactions.pointerMoveTolerance\n}\n\nscope.addListeners({\n  'interactable:unset': ({ interactable }) => {\n    scope.interactables.list.splice(scope.interactables.list.indexOf(interactable), 1)\n\n    // Stop related interactions when an Interactable is unset\n    for (const interaction of scope.interactions.list) {\n      if (interaction.interactable === interactable && interaction.interacting() && !interaction._ending) {\n        interaction.stop()\n      }\n    }\n  },\n})\n\ninteract.addDocument = (doc, options) => scope.addDocument(doc, options)\ninteract.removeDocument = doc => scope.removeDocument(doc)\n\nscope.interact = interact\n\nexport { scope }\nexport default interact\n"
	]
}