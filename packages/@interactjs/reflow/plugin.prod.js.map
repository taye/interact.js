{"version":3,"file":"plugin.prod.js","sources":["plugin.ts"],"sourcesContent":["import type { Interactable } from '@interactjs/core/Interactable'\nimport type { DoAnyPhaseArg, Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, ActionProps, Element } from '@interactjs/core/types'\nimport * as arr from '@interactjs/utils/arr'\nimport { copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport { tlbrToXywh } from '@interactjs/utils/rect'\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-reflow': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-reflow': DoAnyPhaseArg\n    'interactions:after-action-reflow': DoAnyPhaseArg\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    /**\n     * ```js\n     * const interactable = interact(target)\n     * const drag = { name: drag, axis: 'x' }\n     * const resize = { name: resize, edges: { left: true, bottom: true }\n     *\n     * interactable.reflow(drag)\n     * interactable.reflow(resize)\n     * ```\n     *\n     * Start an action sequence to re-apply modifiers, check drops, etc.\n     *\n     * @param { Object } action The action to begin\n     * @param { string } action.name The name of the action\n     * @returns { Promise } A promise that resolves to the `Interactable` when actions on all targets have ended\n     */\n    reflow<T extends ActionName>(action: ActionProps<T>): ReturnType<typeof doReflow>\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    _reflowPromise: Promise<void>\n    _reflowResolve: (...args: unknown[]) => void\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    reflow?: true\n  }\n}\n\nfunction install(scope: Scope) {\n  const { Interactable } = scope\n\n  scope.actions.phases.reflow = true\n\n  Interactable.prototype.reflow = function (action: ActionProps) {\n    return doReflow(this, action, scope)\n  }\n}\n\nfunction doReflow<T extends ActionName>(\n  interactable: Interactable,\n  action: ActionProps<T>,\n  scope: Scope,\n): Promise<Interactable> {\n  const elements = interactable.getAllElements()\n\n  // tslint:disable-next-line variable-name\n  const Promise = (scope.window as any).Promise\n  const promises: Array<Promise<null>> | null = Promise ? [] : null\n\n  for (const element of elements) {\n    const rect = interactable.getRect(element as HTMLElement | SVGElement)\n\n    if (!rect) {\n      break\n    }\n\n    const runningInteraction = arr.find(scope.interactions.list, (interaction: Interaction) => {\n      return (\n        interaction.interacting() &&\n        interaction.interactable === interactable &&\n        interaction.element === element &&\n        interaction.prepared.name === action.name\n      )\n    })\n    let reflowPromise: Promise<null>\n\n    if (runningInteraction) {\n      runningInteraction.move()\n\n      if (promises) {\n        reflowPromise =\n          runningInteraction._reflowPromise ||\n          new Promise((resolve: any) => {\n            runningInteraction._reflowResolve = resolve\n          })\n      }\n    } else {\n      const xywh = tlbrToXywh(rect)\n      const coords = {\n        page: { x: xywh.x, y: xywh.y },\n        client: { x: xywh.x, y: xywh.y },\n        timeStamp: scope.now(),\n      }\n\n      const event = pointerUtils.coordsToEvent(coords)\n      reflowPromise = startReflow<T>(scope, interactable, element, action, event)\n    }\n\n    if (promises) {\n      promises.push(reflowPromise)\n    }\n  }\n\n  return promises && Promise.all(promises).then(() => interactable)\n}\n\nfunction startReflow<T extends ActionName>(\n  scope: Scope,\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  event: any,\n) {\n  const interaction = scope.interactions.new({ pointerType: 'reflow' })\n  const signalArg = {\n    interaction,\n    event,\n    pointer: event,\n    eventTarget: element,\n    phase: 'reflow',\n  } as const\n\n  interaction.interactable = interactable\n  interaction.element = element\n  interaction.prevEvent = event\n  interaction.updatePointer(event, event, element, true)\n  pointerUtils.setZeroCoords(interaction.coords.delta)\n\n  copyAction(interaction.prepared, action)\n  interaction._doPhase(signalArg)\n\n  const { Promise } = scope.window as unknown as { Promise: PromiseConstructor }\n  const reflowPromise = Promise\n    ? new Promise<undefined>((resolve) => {\n        interaction._reflowResolve = resolve\n      })\n    : undefined\n\n  interaction._reflowPromise = reflowPromise\n  interaction.start(action, interactable, element)\n\n  if (interaction._interacting) {\n    interaction.move(signalArg)\n    interaction.end(event)\n  } else {\n    interaction.stop()\n    interaction._reflowResolve()\n  }\n\n  interaction.removePointer(event, event)\n\n  return reflowPromise\n}\n\nconst reflow: Plugin = {\n  id: 'reflow',\n  install,\n  listeners: {\n    // remove completed reflow interactions\n    'interactions:stop': ({ interaction }, scope) => {\n      if (interaction.pointerType === 'reflow') {\n        if (interaction._reflowResolve) {\n          interaction._reflowResolve()\n        }\n\n        arr.remove(scope.interactions.list, interaction)\n      }\n    },\n  },\n}\n\nexport default reflow\n"],"names":["install","Interactable","scope","phases","reflow","prototype","action","this","doReflow","interactable","elements","Promise","window","rect","element","runningInteraction","arr","find","interactions","list","interaction","prepared","name","reflowPromise","promises","_reflowPromise","resolve","xywh","tlbrToXywh","page","x","client","timeStamp","now","event","pointerUtils","coordsToEvent","coords","all","then","startReflow","pointerType","signalArg","pointer","eventTarget","prevEvent","setZeroCoords","delta","copyAction","_doPhase","undefined","start","_interacting","move","stop","removePointer","id","_ref","_reflowResolve","remove"],"mappings":";;oNAoDSA,MAAAA,aACDC,GAAEA,EAAcC,UAAQC,OAAAC,QAAA,EAE9BF,EAAaG,UAAQD,OAAS,SAAIE,GAElCL,OAAAA,SAAsBM,OAAUL,EAC9B,EAEJ,SAAAM,SAAAC,EAAAH,EAAAJ,GAEA,MAAAQ,EACED,EACAH,iBAKAK,EAAAT,EAAAU,OAAAD,QACMA,EAAWT,EAAY,QAC7B,IAAA,WAA8CS,EAAe,CAExD,MAAAE,EAAaJ,UAAcK,GAC9B,IAAAD,EAEA,MAEA,MAAAE,EAAAC,IAAAC,KAAAf,EAAAgB,aAAAC,MAAAC,GAEML,EAAAA,eAAmCK,EAAaX,kBAAqCW,EAAAN,UAAAA,GAAAM,EAAAC,SAAAC,OAAAhB,EAAAgB,OAO3F,IAAEC,EACF,GAAIA,EAEJR,SACoBS,IAElBD,EAAcR,EAAAU,gBAAA,IAAAd,GAAAe,IACZH,EACER,eAAmBU,CAAAA,SAIvB,CACK,MAAAE,EAAAC,WAAAf,GACCc,GACNE,QACQF,EAAAG,EAAEA,EAAGH,EAAKG,GAAcC,OAAA,KACtBD,EAAEA,EAAGH,EAAKG,GAAcE,UAAA9B,EAAA+B,OAEjCC,EAAAC,aAAAC,cAAAC,GAEDd,EAAcY,YAA0BjC,EAAAO,EAAQK,EAAAR,EAAA4B,EAChDX,CACFC,GAEAA,OAAcD,EAEd,CACF,OAAAC,GAAAb,EAAA2B,IAAAd,GAAAe,MAAA,IAAA9B,GAEA,CACF,SAAA+B,YAAAtC,EAAAO,EAAAK,EAAAR,EAAA4B,GAESM,MAAAA,EACPtC,EACAO,aACAK,IAAAA,CAIA2B,uBAAqEC,EAAA,CACrEtB,cACEA,QACAc,QAAKA,EACLS,YAAc7B,EACd8B,MAAAA,YAEQnC,aAAAA,EAEVW,EAAYX,QAAYK,EACxBM,EAAYN,YACZM,EAAYyB,gBAAiBX,EAAApB,GAAA,GAC7BM,aAAyB0B,cAAM1B,EAAOiB,OAASU,OAC/CZ,WAAAA,EAAaW,SAAc1B,GAE3B4B,EAAsBC,SAAAP,GACtBtB,cAEMT,GAAEA,EAAAA,OAAYT,EAA0DS,EAAA,IAAAA,GAAAe,IAC9EN,kBACQT,SACSuC,EAejB9B,OAdKA,EACD8B,eAAS3B,EAEbH,EAAYK,MAAcnB,EAAAG,KAC1BW,EAAY+B,cAER/B,EAAAA,KAAYgC,GACdhC,EAAYiC,IAAInB,KAEXd,EAAAkC,OACLlC,EAAYkC,kBAEdlC,EAAAmC,cAAArB,EAAAA,GAEAd,CAEA,CACF,MAAAhB,OAAA,CAEAoD,GAAMpD,SACJoD,gBACAxD,UAAO,CAEL,mBAQE,CARFyD,EAAAvD,mBACsBkB,GAAEA,EAAa,WAAAqC,EAAAhB,cACpBrB,EAAYsC,gBACrBtC,EAAAA,iBAEJJ,IAAA2C,OAAAzD,EAAAgB,aAAAC,KAAAC,cAMRhB"}