{"version":3,"file":"base-PHHQHneY.js","sources":["base.ts"],"sourcesContent":["import type { Eventable } from '@interactjs/core/Eventable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { Point, PointerType, PointerEventType, Element } from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\n\nimport { PointerEvent } from './PointerEvent'\n\nexport type EventTargetList = Array<{\n  node: Node\n  eventable: Eventable\n  props: { [key: string]: any }\n}>\n\nexport interface PointerEventOptions extends PerActionDefaults {\n  enabled?: undefined // not used\n  holdDuration?: number\n  ignoreFrom?: any\n  allowFrom?: any\n  origin?: Point | string | Element\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    pointerEvents: typeof pointerEvents\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    prevTap?: PointerEvent<string>\n    tapTime?: number\n  }\n}\n\ndeclare module '@interactjs/core/PointerInfo' {\n  interface PointerInfo {\n    hold?: {\n      duration: number\n      timeout: any\n    }\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    pointerEvents: Options\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'pointerEvents:new': { pointerEvent: PointerEvent<any> }\n    'pointerEvents:fired': {\n      interaction: Interaction<null>\n      pointer: PointerType | PointerEvent<any>\n      event: PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      pointerEvent: PointerEvent<any>\n      targets?: EventTargetList\n      type: string\n    }\n    'pointerEvents:collect-targets': {\n      interaction: Interaction<any>\n      pointer: PointerType | PointerEvent<any>\n      event: PointerEventType | PointerEvent<any>\n      eventTarget: Node\n      targets?: EventTargetList\n      type: string\n      path: Node[]\n      node: null\n    }\n  }\n}\n\nconst defaults: PointerEventOptions = {\n  holdDuration: 600,\n  ignoreFrom: null,\n  allowFrom: null,\n  origin: { x: 0, y: 0 },\n}\n\nconst pointerEvents: Plugin = {\n  id: 'pointer-events/base',\n  before: ['inertia', 'modifiers', 'auto-start', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': addInteractionProps,\n    'interactions:update-pointer': addHoldInfo,\n    'interactions:move': moveAndClearHold,\n    'interactions:down': (arg, scope) => {\n      downAndStartHold(arg, scope)\n      fire(arg, scope)\n    },\n    'interactions:up': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n      tapAfterUp(arg, scope)\n    },\n    'interactions:cancel': (arg, scope) => {\n      clearHold(arg)\n      fire(arg, scope)\n    },\n  },\n  PointerEvent,\n  fire,\n  collectEventTargets,\n  defaults,\n  types: {\n    down: true,\n    move: true,\n    up: true,\n    cancel: true,\n    tap: true,\n    doubletap: true,\n    hold: true,\n  } as { [type: string]: true },\n}\n\nfunction fire<T extends string>(\n  arg: {\n    pointer: PointerType | PointerEvent<any>\n    event: PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    interaction: Interaction<never>\n    type: T\n    targets?: EventTargetList\n  },\n  scope: Scope,\n) {\n  const { interaction, pointer, event, eventTarget, type, targets = collectEventTargets(arg, scope) } = arg\n\n  const pointerEvent = new PointerEvent(type, pointer, event, eventTarget, interaction, scope.now())\n\n  scope.fire('pointerEvents:new', { pointerEvent })\n\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    targets,\n    type,\n    pointerEvent,\n  }\n\n  for (let i = 0; i < targets.length; i++) {\n    const target = targets[i]\n\n    for (const prop in target.props || {}) {\n      ;(pointerEvent as any)[prop] = target.props[prop]\n    }\n\n    const origin = getOriginXY(target.eventable, target.node)\n\n    pointerEvent._subtractOrigin(origin)\n    pointerEvent.eventable = target.eventable\n    pointerEvent.currentTarget = target.node\n\n    target.eventable.fire(pointerEvent)\n\n    pointerEvent._addOrigin(origin)\n\n    if (\n      pointerEvent.immediatePropagationStopped ||\n      (pointerEvent.propagationStopped &&\n        i + 1 < targets.length &&\n        targets[i + 1].node !== pointerEvent.currentTarget)\n    ) {\n      break\n    }\n  }\n\n  scope.fire('pointerEvents:fired', signalArg)\n\n  if (type === 'tap') {\n    // if pointerEvent should make a double tap, create and fire a doubletap\n    // PointerEvent and use that as the prevTap\n    const prevTap = pointerEvent.double\n      ? fire(\n          {\n            interaction,\n            pointer,\n            event,\n            eventTarget,\n            type: 'doubletap',\n          },\n          scope,\n        )\n      : pointerEvent\n\n    interaction.prevTap = prevTap\n    interaction.tapTime = prevTap.timeStamp\n  }\n\n  return pointerEvent\n}\n\nfunction collectEventTargets<T extends string>(\n  {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n  }: {\n    interaction: Interaction<any>\n    pointer: PointerType | PointerEvent<any>\n    event: PointerEventType | PointerEvent<any>\n    eventTarget: Node\n    type: T\n  },\n  scope: Scope,\n) {\n  const pointerIndex = interaction.getPointerIndex(pointer)\n  const pointerInfo = interaction.pointers[pointerIndex]\n\n  // do not fire a tap event if the pointer was moved before being lifted\n  if (\n    type === 'tap' &&\n    (interaction.pointerWasMoved ||\n      // or if the pointerup target is different to the pointerdown target\n      !(pointerInfo && pointerInfo.downTarget === eventTarget))\n  ) {\n    return []\n  }\n\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type,\n    path,\n    targets: [] as EventTargetList,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (type === 'hold') {\n    signalArg.targets = signalArg.targets.filter(\n      (target) =>\n        target.eventable.options.holdDuration === interaction.pointers[pointerIndex]?.hold?.duration,\n    )\n  }\n\n  return signalArg.targets\n}\n\nfunction addInteractionProps({ interaction }) {\n  interaction.prevTap = null // the most recent tap event on this interaction\n  interaction.tapTime = 0 // time of the most recent tap event\n}\n\nfunction addHoldInfo({ down, pointerInfo }: SignalArgs['interactions:update-pointer']) {\n  if (!down && pointerInfo.hold) {\n    return\n  }\n\n  pointerInfo.hold = { duration: Infinity, timeout: null }\n}\n\nfunction clearHold({ interaction, pointerIndex }) {\n  const hold = interaction.pointers[pointerIndex].hold\n\n  if (hold && hold.timeout) {\n    clearTimeout(hold.timeout)\n    hold.timeout = null\n  }\n}\n\nfunction moveAndClearHold(arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction, pointer, event, eventTarget, duplicate } = arg\n\n  if (!duplicate && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {\n    if (interaction.pointerIsDown) {\n      clearHold(arg)\n    }\n\n    fire(\n      {\n        interaction,\n        pointer,\n        event,\n        eventTarget: eventTarget as Element,\n        type: 'move',\n      },\n      scope,\n    )\n  }\n}\n\nfunction downAndStartHold(\n  { interaction, pointer, event, eventTarget, pointerIndex }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  const timer = interaction.pointers[pointerIndex].hold!\n  const path = domUtils.getPath(eventTarget as Element | Document)\n  const signalArg = {\n    interaction,\n    pointer,\n    event,\n    eventTarget,\n    type: 'hold',\n    targets: [] as EventTargetList,\n    path,\n    node: null,\n  }\n\n  for (const node of path) {\n    signalArg.node = node\n\n    scope.fire('pointerEvents:collect-targets', signalArg)\n  }\n\n  if (!signalArg.targets.length) return\n\n  let minDuration = Infinity\n\n  for (const target of signalArg.targets) {\n    const holdDuration = target.eventable.options.holdDuration\n\n    if (holdDuration < minDuration) {\n      minDuration = holdDuration\n    }\n  }\n\n  timer.duration = minDuration\n  timer.timeout = setTimeout(() => {\n    fire(\n      {\n        interaction,\n        eventTarget,\n        pointer,\n        event,\n        type: 'hold',\n      },\n      scope,\n    )\n  }, minDuration)\n}\n\nfunction tapAfterUp(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:up'],\n  scope: Scope,\n) {\n  if (!interaction.pointerWasMoved) {\n    fire({ interaction, eventTarget, pointer, event, type: 'tap' }, scope)\n  }\n}\n\nfunction install(scope: Scope) {\n  scope.pointerEvents = pointerEvents\n  scope.defaults.actions.pointerEvents = pointerEvents.defaults\n  extend(scope.actions.phaselessTypes, pointerEvents.types)\n}\n\nexport default pointerEvents\n"],"names":["holdDuration","ignoreFrom","allowFrom","x","pointerEvents","id","before","install","addInteractionProps","addHoldInfo","moveAndClearHold","fire","arg","scope","downAndStartHold","tapAfterUp","clearHold","PointerEvent","collectEventTargets","defaults","down","move","up","cancel","tap","doubletap","interaction","pointer","event","eventTarget","type","targets","now","pointerEvent","signalArg","i","length","target","prop","props","origin","getOriginXY","eventable","node","_subtractOrigin","currentTarget","_addOrigin","propagationStopped","prevTap","double","timeStamp","_ref","getPointerIndex","pointerIndex","pointers","pointerWasMoved","pointerInfo","downTarget","path","domUtils","getPath","filter","_interaction$pointers2","_interaction$pointers","hold","duration","_ref2","_ref3","_ref4","timeout","clearTimeout","duplicate","pointerIsDown","_ref5","timer","minDuration","Infinity","options","setTimeout","_ref6","actions","pointerEvents$1","Object","freeze"],"mappings":"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"}