{"version":3,"file":"holdRepeat.prod.js","sources":["holdRepeat.ts"],"sourcesContent":["import type Interaction from '@interactjs/core/Interaction'\nimport type { ListenerMap, Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './base'\nimport basePlugin from './base'\n/* eslint-enable import/no-duplicates */\nimport { type PointerEvent } from './PointerEvent'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    holdIntervalHandle?: any\n  }\n}\n\ndeclare module '@interactjs/pointer-events/PointerEvent' {\n  interface PointerEvent<T extends string = any> {\n    count?: number\n  }\n}\n\ndeclare module '@interactjs/pointer-events/base' {\n  interface PointerEventOptions {\n    holdRepeatInterval?: number\n  }\n}\n\nfunction install(scope: Scope) {\n  scope.usePlugin(basePlugin)\n\n  const { pointerEvents } = scope\n\n  // don't repeat by default\n  pointerEvents.defaults.holdRepeatInterval = 0\n  pointerEvents.types.holdrepeat = scope.actions.phaselessTypes.holdrepeat = true\n}\n\nfunction onNew({ pointerEvent }: { pointerEvent: PointerEvent<any> }) {\n  if (pointerEvent.type !== 'hold') return\n\n  pointerEvent.count = (pointerEvent.count || 0) + 1\n}\n\nfunction onFired(\n  { interaction, pointerEvent, eventTarget, targets }: SignalArgs['pointerEvents:fired'],\n  scope: Scope,\n) {\n  if (pointerEvent.type !== 'hold' || !targets.length) return\n\n  // get the repeat interval from the first eventable\n  const interval = targets[0].eventable.options.holdRepeatInterval\n\n  // don't repeat if the interval is 0 or less\n  if (interval <= 0) return\n\n  // set a timeout to fire the holdrepeat event\n  interaction.holdIntervalHandle = setTimeout(() => {\n    scope.pointerEvents.fire(\n      {\n        interaction,\n        eventTarget,\n        type: 'hold',\n        pointer: pointerEvent,\n        event: pointerEvent,\n      },\n      scope,\n    )\n  }, interval)\n}\n\nfunction endHoldRepeat({ interaction }: { interaction: Interaction }) {\n  // set the interaction's holdStopTime property\n  // to stop further holdRepeat events\n  if (interaction.holdIntervalHandle) {\n    clearInterval(interaction.holdIntervalHandle)\n    interaction.holdIntervalHandle = null\n  }\n}\n\nconst holdRepeat: Plugin = {\n  id: 'pointer-events/holdRepeat',\n  install,\n  listeners: ['move', 'up', 'cancel', 'endall'].reduce(\n    (acc, enderTypes) => {\n      ;(acc as any)[`pointerEvents:${enderTypes}`] = endHoldRepeat\n      return acc\n    },\n    {\n      'pointerEvents:new': onNew,\n      'pointerEvents:fired': onFired,\n    } as ListenerMap,\n  ),\n}\n\nexport default holdRepeat\n"],"names":["install","scope","usePlugin","basePlugin","pointerEvents","defaults","holdRepeatInterval","types","holdrepeat","actions","phaselessTypes","onNew","_ref","pointerEvent","type","count","onFired","_ref2","interaction","eventTarget","targets","length","interval","eventable","options","holdIntervalHandle","setTimeout","fire","pointer","event","endHoldRepeat","_ref3","clearInterval","holdRepeat","id","listeners","reduce","acc","enderTypes"],"mappings":";;iQA2BA,SAASA,QAAQC,GACfA,EAAMC,UAAUC,eAEhB,MAAQC,cAAAA,GAAkBH,EAG1BG,EAAcC,SAASC,mBAAqB,EAC5CF,EAAcG,MAAMC,WAAaP,EAAMQ,QAAQC,eAAeF,YAAa,CAC7E,CAEA,SAASG,MAAKC,GAAwD,IAAvDC,aAAEA,GAAmDD,EACxC,SAAtBC,EAAaC,OAEjBD,EAAaE,OAASF,EAAaE,OAAS,GAAK,EACnD,CAEA,SAASC,QAAOC,EAEdhB,GACA,IAFAiB,YAAEA,EAAWL,aAAEA,EAAYM,YAAEA,EAAWC,QAAEA,GAA4CH,EAGtF,GAA0B,SAAtBJ,EAAaC,OAAoBM,EAAQC,OAAQ,OAGrD,MAAMC,EAAWF,EAAQ,GAAGG,UAAUC,QAAQlB,mBAG1CgB,GAAY,IAGhBJ,EAAYO,mBAAqBC,YAAW,KAC1CzB,EAAMG,cAAcuB,KAClB,CACET,cACAC,cACAL,KAAM,OACNc,QAASf,EACTgB,MAAOhB,GAETZ,EACD,GACAqB,GACL,CAEA,SAASQ,cAAaC,GAAgD,IAA/Cb,YAAEA,GAA2Ca,EAG9Db,EAAYO,qBACdO,cAAcd,EAAYO,oBAC1BP,EAAYO,mBAAqB,KAErC,CAEA,MAAMQ,WAAqB,CACzBC,GAAI,4BACJlC,gBACAmC,UAAW,CAAC,OAAQ,KAAM,SAAU,UAAUC,QAC5C,CAACC,EAAKC,KACFD,EAAa,iBAAgBC,GAAgBR,cACxCO,IAET,CACE,oBAAqB1B,MACrB,sBAAuBK"}