{
	"version": 3,
	"sources": [
		"base.ts"
	],
	"names": [
		"InteractableMethods",
		"utils",
		"validateAction",
		"action",
		"interactable",
		"element",
		"eventTarget",
		"scope",
		"testIgnoreAllow",
		"options",
		"name",
		"enabled",
		"withinInteractionLimit",
		"validateMatches",
		"interaction",
		"pointer",
		"event",
		"matches",
		"matchElements",
		"i",
		"len",
		"length",
		"match",
		"matchElement",
		"matchAction",
		"getAction",
		"getActionInfo",
		"pushMatches",
		"push",
		"is",
		"interactables",
		"forEachMatch",
		"actionInfo",
		"manualStart",
		"dom",
		"parentNode",
		"prepare",
		"copyAction",
		"prepared",
		"rect",
		"getRect",
		"setInteractionCursor",
		"fire",
		"maxActions",
		"max",
		"maxPerElement",
		"autoStartMax",
		"autoStart",
		"maxInteractions",
		"activeInteractions",
		"interactableCount",
		"elementCount",
		"interactions",
		"list",
		"otherAction",
		"interacting",
		"newValue",
		"number",
		"this",
		"setCursor",
		"cursor",
		"cursorElement",
		"prevCursorElement",
		"style",
		"ownerDocument",
		"documentElement",
		"pointerType",
		"styleCursor",
		"cursorChecker",
		"func",
		"_interacting",
		"actions",
		"map",
		"getCursor",
		"id",
		"before",
		"install",
		"interactStatic",
		"interact",
		"defaults",
		"usePlugin",
		"base",
		"actionChecker",
		"extend",
		"perAction",
		"Infinity",
		"allowFrom",
		"ignoreFrom",
		"mouseButtons",
		"listeners",
		"[object Object]",
		"arg",
		"pointerIsDown",
		"prepareOnMove",
		"pointerWasMoved",
		"actionName",
		"stop",
		"start",
		"startOnMove"
	],
	"mappings": "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",
	"sourcesContent": [
		"import InteractableMethods from './InteractableMethods'\nimport * as utils from '@interactjs/utils/index'\n\ndeclare module '@interactjs/core/InteractStatic' {\n  interface InteractStatic {\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n    maxInteractions: (...args: any[]) => any\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Interact.SignalArgs['interactions:move']\n    'autoStart:prepared': { interaction: Interact.Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Interact.Element\n    ignoreFrom?: string | Interact.Element\n    cursorChecker?: Interact.CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons?: 0 | 1 | 2 | 4 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interact.Interactable\n  interaction: Interact.Interaction\n  element: Interact.Element\n  action: Interact.ActionProps\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Interact.Element\n}\n\nfunction install (scope: Interact.Scope) {\n  const {\n    interactStatic: interact,\n    defaults,\n  } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  utils.extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom:  null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  /**\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\n   * default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables and\n   * elements, you need to enable it in the draggable, resizable and gesturable\n   * `'max'` and `'maxPerElement'` options.\n   *\n   * @alias module:interact.maxInteractions\n   *\n   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n   */\n  interact.maxInteractions = newValue => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown ({ interaction, pointer, event, eventTarget }: Interact.SignalArgs['interactions:down'], scope: Interact.Scope) {\n  if (interaction.interacting()) { return }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove ({ interaction, pointer, event, eventTarget }: Interact.SignalArgs['interactions:move'], scope: Interact.Scope) {\n  if (interaction.pointerType !== 'mouse' ||\n      interaction.pointerIsDown ||\n      interaction.interacting()) { return }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Interact.Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove (arg: Interact.SignalArgs['interactions:move'], scope: Interact.Scope) {\n  const { interaction } = arg\n\n  if (!interaction.pointerIsDown ||\n      interaction.interacting() ||\n      !interaction.pointerWasMoved ||\n      !interaction.prepared.name) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = interaction.prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (interactable.options[actionName].manualStart ||\n        !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)) {\n      interaction.stop()\n    }\n    else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop ({ interaction }: { interaction: Interact.Interaction }, scope: Interact.Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends Interact.ActionName> (\n  action: Interact.ActionProps<T>,\n  interactable: Interact.Interactable,\n  element: Interact.Element,\n  eventTarget: Interact.EventTarget,\n  scope: Interact.Scope,\n) {\n  if (interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n      interactable.options[action.name].enabled &&\n      withinInteractionLimit(interactable, element, action, scope)) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches (\n  interaction: Interact.Interaction,\n  pointer: Interact.PointerType,\n  event: Interact.PointerEventType,\n  matches: Interact.Interactable[],\n  matchElements: Interact.Element[],\n  eventTarget: Interact.EventTarget,\n  scope: Interact.Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) { continue }\n\n    const action = validateAction(\n      matchAction,\n      match,\n      matchElement,\n      eventTarget,\n      scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo (\n  interaction: Interact.Interaction,\n  pointer: Interact.PointerType,\n  event: Interact.PointerEventType,\n  eventTarget: Interact.EventTarget,\n  scope: Interact.Scope,\n) {\n  let matches: Interact.Interactable[] = []\n  let matchElements: Interact.Element[] = []\n\n  let element = eventTarget as Interact.Element\n\n  function pushMatches (interactable: Interact.Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (utils.is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope)\n\n    if (actionInfo.action &&\n      !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = utils.dom.parentNode(element) as Interact.Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare (\n  interaction: Interact.Interaction,\n  { action, interactable, element }: {\n    action: Interact.ActionProps\n    interactable: Interact.Interactable\n    element: Interact.Element\n  },\n  scope: Interact.Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  utils.copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name\n    ? interactable.getRect(element)\n    : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends Interact.ActionName> (\n  interactable: Interact.Interactable,\n  element: Interact.Element,\n  action: Interact.ActionProps<T>,\n  scope: Interact.Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) { return false }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) { continue }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) { continue }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions (newValue: any, scope: Interact.Scope) {\n  if (utils.is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor (element: Interact.Element, cursor: string, scope: Interact.Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends Interact.ActionName> (interaction: Interact.Interaction<T>, scope: Interact.Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker: Interact.CursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (utils.is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    }\n    else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Interact.Plugin = {\n  id: 'auto-start/base',\n  before: ['actions', 'actions/drag', 'actions/resize', 'actions/gesture'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n} as Interact.Plugin\n\nexport default autoStart\n"
	]
}