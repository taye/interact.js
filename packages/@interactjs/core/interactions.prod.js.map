{"version":3,"file":"interactions.prod.js","sources":["interactions.ts"],"sourcesContent":["import browser from '@interactjs/utils/browser'\nimport domObjects from '@interactjs/utils/domObjects'\nimport { nodeContains } from '@interactjs/utils/domUtils'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, Listener } from '@interactjs/core/types'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './interactablePreventDefault'\nimport interactablePreventDefault from './interactablePreventDefault'\nimport InteractionBase from './Interaction'\n/* eslint-enable import/no-duplicates */\nimport type { SearchDetails } from './interactionFinder'\nimport finder from './interactionFinder'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    Interaction: typeof InteractionBase\n    interactions: {\n      new: <T extends ActionName>(options: any) => InteractionBase<T>\n      list: Array<InteractionBase<ActionName>>\n      listeners: { [type: string]: Listener }\n      docEvents: Array<{ type: string; listener: Listener }>\n      pointerMoveTolerance: number\n    }\n    prevTouchTime: number\n  }\n\n  interface SignalArgs {\n    'interactions:find': {\n      interaction: InteractionBase\n      searchDetails: SearchDetails\n    }\n  }\n}\n\nconst methodNames = [\n  'pointerDown',\n  'pointerMove',\n  'pointerUp',\n  'updatePointer',\n  'removePointer',\n  'windowBlur',\n]\n\nfunction install(scope: Scope) {\n  const listeners = {} as any\n\n  for (const method of methodNames) {\n    listeners[method] = doOnInteractions(method, scope)\n  }\n\n  const pEventTypes = browser.pEventTypes\n  let docEvents: typeof scope.interactions.docEvents\n\n  if (domObjects.PointerEvent) {\n    docEvents = [\n      { type: pEventTypes.down, listener: releasePointersOnRemovedEls },\n      { type: pEventTypes.down, listener: listeners.pointerDown },\n      { type: pEventTypes.move, listener: listeners.pointerMove },\n      { type: pEventTypes.up, listener: listeners.pointerUp },\n      { type: pEventTypes.cancel, listener: listeners.pointerUp },\n    ]\n  } else {\n    docEvents = [\n      { type: 'mousedown', listener: listeners.pointerDown },\n      { type: 'mousemove', listener: listeners.pointerMove },\n      { type: 'mouseup', listener: listeners.pointerUp },\n\n      { type: 'touchstart', listener: releasePointersOnRemovedEls },\n      { type: 'touchstart', listener: listeners.pointerDown },\n      { type: 'touchmove', listener: listeners.pointerMove },\n      { type: 'touchend', listener: listeners.pointerUp },\n      { type: 'touchcancel', listener: listeners.pointerUp },\n    ]\n  }\n\n  docEvents.push({\n    type: 'blur',\n    listener(event) {\n      for (const interaction of scope.interactions.list) {\n        interaction.documentBlur(event)\n      }\n    },\n  })\n\n  // for ignoring browser's simulated mouse events\n  scope.prevTouchTime = 0\n\n  scope.Interaction = class<T extends ActionName> extends InteractionBase<T> {\n    get pointerMoveTolerance() {\n      return scope.interactions.pointerMoveTolerance\n    }\n\n    set pointerMoveTolerance(value) {\n      scope.interactions.pointerMoveTolerance = value\n    }\n\n    _now() {\n      return scope.now()\n    }\n  }\n\n  scope.interactions = {\n    // all active and idle interactions\n    list: [],\n    new<T extends ActionName>(options: { pointerType?: string; scopeFire?: Scope['fire'] }) {\n      options.scopeFire = (name, arg) => scope.fire(name, arg)\n\n      const interaction = new scope.Interaction<T>(options as Required<typeof options>)\n\n      scope.interactions.list.push(interaction)\n      return interaction\n    },\n    listeners,\n    docEvents,\n    pointerMoveTolerance: 1,\n  }\n\n  function releasePointersOnRemovedEls() {\n    // for all inactive touch interactions with pointers down\n    for (const interaction of scope.interactions.list) {\n      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {\n        continue\n      }\n\n      // if a pointer is down on an element that is no longer in the DOM tree\n      for (const pointer of interaction.pointers) {\n        if (!scope.documents.some(({ doc }) => nodeContains(doc, pointer.downTarget))) {\n          // remove the pointer from the interaction\n          interaction.removePointer(pointer.pointer, pointer.event)\n        }\n      }\n    }\n  }\n\n  scope.usePlugin(interactablePreventDefault)\n}\n\nfunction doOnInteractions(method: string, scope: Scope) {\n  return function (event: Event) {\n    const interactions = scope.interactions.list\n\n    const pointerType = pointerUtils.getPointerType(event)\n    const [eventTarget, curEventTarget] = pointerUtils.getEventTargets(event)\n    const matches: any[] = [] // [ [pointer, interaction], ...]\n\n    if (/^touch/.test(event.type)) {\n      scope.prevTouchTime = scope.now()\n\n      // @ts-expect-error\n      for (const changedTouch of event.changedTouches) {\n        const pointer = changedTouch\n        const pointerId = pointerUtils.getPointerId(pointer)\n        const searchDetails: SearchDetails = {\n          pointer,\n          pointerId,\n          pointerType,\n          eventType: event.type,\n          eventTarget,\n          curEventTarget,\n          scope,\n        }\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    } else {\n      let invalidPointer = false\n\n      if (!browser.supportsPointerEvent && /mouse/.test(event.type)) {\n        // ignore mouse events while touch interactions are active\n        for (let i = 0; i < interactions.length && !invalidPointer; i++) {\n          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown\n        }\n\n        // try to ignore mouse events that are simulated by the browser\n        // after a touch event\n        invalidPointer =\n          invalidPointer ||\n          scope.now() - scope.prevTouchTime < 500 ||\n          // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated\n          event.timeStamp === 0\n      }\n\n      if (!invalidPointer) {\n        const searchDetails = {\n          pointer: event as PointerEvent,\n          pointerId: pointerUtils.getPointerId(event as PointerEvent),\n          pointerType,\n          eventType: event.type,\n          curEventTarget,\n          eventTarget,\n          scope,\n        }\n\n        const interaction = getInteraction(searchDetails)\n\n        matches.push([\n          searchDetails.pointer,\n          searchDetails.eventTarget,\n          searchDetails.curEventTarget,\n          interaction,\n        ])\n      }\n    }\n\n    // eslint-disable-next-line no-shadow\n    for (const [pointer, eventTarget, curEventTarget, interaction] of matches) {\n      interaction[method](pointer, event, eventTarget, curEventTarget)\n    }\n  }\n}\n\nfunction getInteraction(searchDetails: SearchDetails) {\n  const { pointerType, scope } = searchDetails\n\n  const foundInteraction = finder.search(searchDetails)\n  const signalArg = { interaction: foundInteraction, searchDetails }\n\n  scope.fire('interactions:find', signalArg)\n\n  return signalArg.interaction || scope.interactions.new({ pointerType })\n}\n\nfunction onDocSignal<T extends 'scope:add-document' | 'scope:remove-document'>(\n  { doc, scope, options }: SignalArgs[T],\n  eventMethodName: 'add' | 'remove',\n) {\n  const {\n    interactions: { docEvents },\n    events,\n  } = scope\n  const eventMethod = events[eventMethodName]\n\n  if (scope.browser.isIOS && !options.events) {\n    options.events = { passive: false }\n  }\n\n  // delegate event listener\n  for (const eventType in events.delegatedEvents) {\n    eventMethod(doc, eventType, events.delegateListener)\n    eventMethod(doc, eventType, events.delegateUseCapture, true)\n  }\n\n  const eventOptions = options && options.events\n\n  for (const { type, listener } of docEvents) {\n    eventMethod(doc, type, listener, eventOptions)\n  }\n}\n\nconst interactions: Plugin = {\n  id: 'core/interactions',\n  install,\n  listeners: {\n    'scope:add-document': (arg) => onDocSignal(arg, 'add'),\n    'scope:remove-document': (arg) => onDocSignal(arg, 'remove'),\n    'interactable:unset': ({ interactable }, scope) => {\n      // Stop and destroy related interactions when an Interactable is unset\n      for (let i = scope.interactions.list.length - 1; i >= 0; i--) {\n        const interaction = scope.interactions.list[i]\n\n        if (interaction.interactable !== interactable) {\n          continue\n        }\n\n        interaction.stop()\n        scope.fire('interactions:destroy', { interaction })\n        interaction.destroy()\n\n        if (scope.interactions.list.length > 2) {\n          scope.interactions.list.splice(i, 1)\n        }\n      }\n    },\n  },\n  onDocSignal,\n  doOnInteractions,\n  methodNames,\n}\n\nexport default interactions\n"],"names":["install","scope","listeners","methodNames","method","pEventTypes","browser","releasePointersOnRemovedEls","interaction","interactions","list","pointerIsDown","_interacting","pointer","pointers","some","_ref","doc","downTarget","removePointer","event","domObjects","docEvents","PointerEvent","down","type","listener","pointerDown","move","pointerMove","up","pointerUp","cancel","push","documentBlur","prevTouchTime","Interaction","pointerMoveTolerance","value","_now","now","options","new","name","arg","fire","usePlugin","interactablePreventDefault","doOnInteractions","getPointerType","pointerUtils","getEventTargets","matches","changedTouch","changedTouches","pointerId","getPointerId","pointerType","eventType","eventTarget","curEventTarget","getInteraction","searchDetails","invalidPointer","test","i","length","timeStamp","foundInteraction","finder","search","signalArg","onDocSignal","_ref2","eventMethodName","events","isIOS","delegatedEvents","eventMethod","delegateListener","eventOptions","id","_ref3","interactable","stop","destroy"],"mappings":"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"}