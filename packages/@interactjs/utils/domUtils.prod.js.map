{"version":3,"file":"domUtils.prod.js","sources":["domUtils.ts"],"sourcesContent":["import type { Rect, Target, Element } from '@interactjs/core/types'\n\nimport browser from './browser'\nimport domObjects from './domObjects'\nimport is from './is'\nimport * as win from './window'\n\nexport function nodeContains(parent: Node, child: Node) {\n  if (parent.contains) {\n    return parent.contains(child as Node)\n  }\n\n  while (child) {\n    if (child === parent) {\n      return true\n    }\n\n    child = (child as Node).parentNode\n  }\n\n  return false\n}\n\nexport function closest(element: Node, selector: string) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return element\n    }\n\n    element = parentNode(element)\n  }\n\n  return null\n}\n\nexport function parentNode(node: Node | Document) {\n  let parent = node.parentNode\n\n  if (is.docFrag(parent)) {\n    // skip past #shado-root fragments\n    // tslint:disable-next-line\n    while ((parent = (parent as any).host) && is.docFrag(parent)) {\n      continue\n    }\n\n    return parent\n  }\n\n  return parent\n}\n\nexport function matchesSelector(element: Element, selector: string) {\n  // remove /deep/ from selectors if shadowDOM polyfill is used\n  if (win.window !== win.realWindow) {\n    selector = selector.replace(/\\/deep\\//g, ' ')\n  }\n\n  return element[browser.prefixedMatchesSelector](selector)\n}\n\nconst getParent = (el: Node | Document | ShadowRoot) => el.parentNode || (el as ShadowRoot).host\n\n// Test for the element that's \"above\" all other qualifiers\nexport function indexOfDeepestElement(elements: Element[] | NodeListOf<globalThis.Element>) {\n  let deepestNodeParents: Node[] = []\n  let deepestNodeIndex: number\n\n  for (let i = 0; i < elements.length; i++) {\n    const currentNode = elements[i]\n    const deepestNode: Node = elements[deepestNodeIndex]\n\n    // node may appear in elements array multiple times\n    if (!currentNode || i === deepestNodeIndex) {\n      continue\n    }\n\n    if (!deepestNode) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    const currentNodeParent = getParent(currentNode)\n    const deepestNodeParent = getParent(deepestNode)\n\n    // check if the deepest or current are document.documentElement/rootElement\n    // - if the current node is, do nothing and continue\n    if (currentNodeParent === currentNode.ownerDocument) {\n      continue\n    }\n    // - if deepest is, update with the current node and continue to next\n    else if (deepestNodeParent === currentNode.ownerDocument) {\n      deepestNodeIndex = i\n      continue\n    }\n\n    // compare zIndex of siblings\n    if (currentNodeParent === deepestNodeParent) {\n      if (zIndexIsHigherThan(currentNode, deepestNode)) {\n        deepestNodeIndex = i\n      }\n\n      continue\n    }\n\n    // populate the ancestry array for the latest deepest node\n    deepestNodeParents = deepestNodeParents.length ? deepestNodeParents : getNodeParents(deepestNode)\n\n    let ancestryStart: Node\n\n    // if the deepest node is an HTMLElement and the current node is a non root svg element\n    if (\n      deepestNode instanceof domObjects.HTMLElement &&\n      currentNode instanceof domObjects.SVGElement &&\n      !(currentNode instanceof domObjects.SVGSVGElement)\n    ) {\n      // TODO: is this check necessary? Was this for HTML elements embedded in SVG?\n      if (currentNode === deepestNodeParent) {\n        continue\n      }\n\n      ancestryStart = currentNode.ownerSVGElement\n    } else {\n      ancestryStart = currentNode\n    }\n\n    const currentNodeParents = getNodeParents(ancestryStart, deepestNode.ownerDocument)\n    let commonIndex = 0\n\n    // get (position of closest common ancestor) + 1\n    while (\n      currentNodeParents[commonIndex] &&\n      currentNodeParents[commonIndex] === deepestNodeParents[commonIndex]\n    ) {\n      commonIndex++\n    }\n\n    const parents = [\n      currentNodeParents[commonIndex - 1],\n      currentNodeParents[commonIndex],\n      deepestNodeParents[commonIndex],\n    ]\n\n    if (parents[0]) {\n      let child = parents[0].lastChild\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestNodeIndex = i\n          deepestNodeParents = currentNodeParents\n\n          break\n        } else if (child === parents[2]) {\n          break\n        }\n\n        child = child.previousSibling\n      }\n    }\n  }\n\n  return deepestNodeIndex\n}\n\nfunction getNodeParents(node: Node, limit?: Node) {\n  const parents: Node[] = []\n  let parent: Node = node\n  let parentParent: Node\n\n  while ((parentParent = getParent(parent)) && parent !== limit && parentParent !== parent.ownerDocument) {\n    parents.unshift(parent)\n    parent = parentParent\n  }\n\n  return parents\n}\n\nfunction zIndexIsHigherThan(higherNode: Node, lowerNode: Node) {\n  const higherIndex = parseInt(win.getWindow(higherNode).getComputedStyle(higherNode).zIndex, 10) || 0\n  const lowerIndex = parseInt(win.getWindow(lowerNode).getComputedStyle(lowerNode).zIndex, 10) || 0\n\n  return higherIndex >= lowerIndex\n}\n\nexport function matchesUpTo(element: Element, selector: string, limit: Node) {\n  while (is.element(element)) {\n    if (matchesSelector(element, selector)) {\n      return true\n    }\n\n    element = parentNode(element) as Element\n\n    if (element === limit) {\n      return matchesSelector(element, selector)\n    }\n  }\n\n  return false\n}\n\nexport function getActualElement(element: Element) {\n  return (element as any).correspondingUseElement || element\n}\n\nexport function getScrollXY(relevantWindow?: Window) {\n  relevantWindow = relevantWindow || win.window\n  return {\n    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,\n    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop,\n  }\n}\n\nexport function getElementClientRect(element: Element): Required<Rect> {\n  const clientRect =\n    element instanceof domObjects.SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0]\n\n  return (\n    clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top,\n    }\n  )\n}\n\nexport function getElementRect(element: Element) {\n  const clientRect = getElementClientRect(element)\n\n  if (!browser.isIOS7 && clientRect) {\n    const scroll = getScrollXY(win.getWindow(element))\n\n    clientRect.left += scroll.x\n    clientRect.right += scroll.x\n    clientRect.top += scroll.y\n    clientRect.bottom += scroll.y\n  }\n\n  return clientRect\n}\n\nexport function getPath(node: Node | Document) {\n  const path = []\n\n  while (node) {\n    path.push(node)\n    node = parentNode(node)\n  }\n\n  return path\n}\n\nexport function trySelector(value: Target) {\n  if (!is.string(value)) {\n    return false\n  }\n\n  // an exception will be raised if it is invalid\n  domObjects.document.querySelector(value)\n  return true\n}\n"],"names":["parent","nodeContains","contains","child","parentNode","closest","element","selector","node","docFrag","host","is","matchesSelector","win","realWindow","replace","browser","prefixedMatchesSelector","getParent","el","indexOfDeepestElement","elements","deepestNodeParents","length","i","currentNode","deepestNodeIndex","deepestNode","currentNodeParent","ownerDocument","deepestNodeParent","ancestryStart","getNodeParents","domObjects","HTMLElement","SVGElement","SVGSVGElement","ownerSVGElement","currentNodeParents","commonIndex","parents","lastChild","previousSibling","limit","parentParent","unshift","zIndexIsHigherThan","higherNode","lowerNode","getWindow","getComputedStyle","zIndex","parseInt","matchesUpTo","getActualElement","getScrollXY","relevantWindow","x","scrollX","document","documentElement","scrollLeft","getElementClientRect","getBoundingClientRect","getClientRects","left","clientRect","right","top","bottom","width","height","getElementRect","isIOS7","scroll","y","getPath","path","push","trySelector","value","querySelector"],"mappings":"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"}