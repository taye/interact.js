{"version":3,"file":"plugin.prod.js","sources":["plugin.ts"],"sourcesContent":["import type { Interactable } from '@interactjs/core/Interactable'\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, PointerType } from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport raf from '@interactjs/utils/raf'\nimport { getStringOptionResult } from '@interactjs/utils/rect'\nimport { getWindow } from '@interactjs/utils/window'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoScroll: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    autoScroll?: typeof autoScroll\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    autoScroll?: AutoScrollOptions\n  }\n}\n\nexport interface AutoScrollOptions {\n  container?: Window | HTMLElement | string\n  margin?: number\n  distance?: number\n  interval?: number\n  speed?: number\n  enabled?: boolean\n}\n\nfunction install(scope: Scope) {\n  const { defaults, actions } = scope\n\n  scope.autoScroll = autoScroll\n  autoScroll.now = () => scope.now()\n\n  actions.phaselessTypes.autoscroll = true\n  defaults.perAction.autoScroll = autoScroll.defaults\n}\n\nconst autoScroll = {\n  defaults: {\n    enabled: false,\n    margin: 60,\n\n    // the item that is scrolled (Window or HTMLElement)\n    container: null as AutoScrollOptions['container'],\n\n    // the scroll speed in pixels per second\n    speed: 300,\n  } as AutoScrollOptions,\n\n  now: Date.now,\n\n  interaction: null as Interaction<ActionName> | null,\n  i: 0, // the handle returned by window.setInterval\n\n  // Direction each pulse is to scroll in\n  x: 0,\n  y: 0,\n\n  isScrolling: false,\n  prevTime: 0,\n  margin: 0,\n  speed: 0,\n\n  start(interaction: Interaction) {\n    autoScroll.isScrolling = true\n    raf.cancel(autoScroll.i)\n\n    interaction.autoScroll = autoScroll\n    autoScroll.interaction = interaction\n    autoScroll.prevTime = autoScroll.now()\n    autoScroll.i = raf.request(autoScroll.scroll)\n  },\n\n  stop() {\n    autoScroll.isScrolling = false\n    if (autoScroll.interaction) {\n      autoScroll.interaction.autoScroll = null\n    }\n    raf.cancel(autoScroll.i)\n  },\n\n  // scroll the window by the values in scroll.x/y\n  scroll() {\n    const { interaction } = autoScroll\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n    const now = autoScroll.now()\n    // change in time in seconds\n    const dt = (now - autoScroll.prevTime) / 1000\n    // displacement\n    const s = options.speed * dt\n\n    if (s >= 1) {\n      const scrollBy = {\n        x: autoScroll.x * s,\n        y: autoScroll.y * s,\n      }\n\n      if (scrollBy.x || scrollBy.y) {\n        const prevScroll = getScroll(container)\n\n        if (is.window(container)) {\n          container.scrollBy(scrollBy.x, scrollBy.y)\n        } else if (container) {\n          container.scrollLeft += scrollBy.x\n          container.scrollTop += scrollBy.y\n        }\n\n        const curScroll = getScroll(container)\n        const delta = {\n          x: curScroll.x - prevScroll.x,\n          y: curScroll.y - prevScroll.y,\n        }\n\n        if (delta.x || delta.y) {\n          interactable.fire({\n            type: 'autoscroll',\n            target: element,\n            interactable,\n            delta,\n            interaction,\n            container,\n          })\n        }\n      }\n\n      autoScroll.prevTime = now\n    }\n\n    if (autoScroll.isScrolling) {\n      raf.cancel(autoScroll.i)\n      autoScroll.i = raf.request(autoScroll.scroll)\n    }\n  },\n  check(interactable: Interactable, actionName: ActionName) {\n    const options = interactable.options\n\n    return options[actionName].autoScroll?.enabled\n  },\n  onInteractionMove<T extends ActionName>({\n    interaction,\n    pointer,\n  }: {\n    interaction: Interaction<T>\n    pointer: PointerType\n  }) {\n    if (\n      !(interaction.interacting() && autoScroll.check(interaction.interactable, interaction.prepared.name))\n    ) {\n      return\n    }\n\n    if (interaction.simulation) {\n      autoScroll.x = autoScroll.y = 0\n      return\n    }\n\n    let top: boolean\n    let right: boolean\n    let bottom: boolean\n    let left: boolean\n\n    const { interactable, element } = interaction\n    const actionName = interaction.prepared.name\n    const options = interactable.options[actionName].autoScroll\n    const container = getContainer(options.container, interactable, element)\n\n    if (is.window(container)) {\n      left = pointer.clientX < autoScroll.margin\n      top = pointer.clientY < autoScroll.margin\n      right = pointer.clientX > container.innerWidth - autoScroll.margin\n      bottom = pointer.clientY > container.innerHeight - autoScroll.margin\n    } else {\n      const rect = domUtils.getElementClientRect(container)\n\n      left = pointer.clientX < rect.left + autoScroll.margin\n      top = pointer.clientY < rect.top + autoScroll.margin\n      right = pointer.clientX > rect.right - autoScroll.margin\n      bottom = pointer.clientY > rect.bottom - autoScroll.margin\n    }\n\n    autoScroll.x = right ? 1 : left ? -1 : 0\n    autoScroll.y = bottom ? 1 : top ? -1 : 0\n\n    if (!autoScroll.isScrolling) {\n      // set the autoScroll properties to those of the target\n      autoScroll.margin = options.margin\n      autoScroll.speed = options.speed\n\n      autoScroll.start(interaction)\n    }\n  },\n}\n\nexport function getContainer(value: any, interactable: Interactable, element: Element) {\n  return (\n    (is.string(value) ? getStringOptionResult(value, interactable, element) : value) || getWindow(element)\n  )\n}\n\nexport function getScroll(container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollLeft, y: container.scrollTop }\n}\n\nexport function getScrollSize(container: any) {\n  if (is.window(container)) {\n    container = window.document.body\n  }\n\n  return { x: container.scrollWidth, y: container.scrollHeight }\n}\n\nexport function getScrollSizeDelta<T extends ActionName>(\n  {\n    interaction,\n    element,\n  }: {\n    interaction: Partial<Interaction<T>>\n    element: Element\n  },\n  func: any,\n) {\n  const scrollOptions = interaction && interaction.interactable.options[interaction.prepared.name].autoScroll\n\n  if (!scrollOptions || !scrollOptions.enabled) {\n    func()\n    return { x: 0, y: 0 }\n  }\n\n  const scrollContainer = getContainer(scrollOptions.container, interaction.interactable, element)\n\n  const prevSize = getScroll(scrollContainer)\n  func()\n  const curSize = getScroll(scrollContainer)\n\n  return {\n    x: curSize.x - prevSize.x,\n    y: curSize.y - prevSize.y,\n  }\n}\n\nconst autoScrollPlugin: Plugin = {\n  id: 'auto-scroll',\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.autoScroll = null\n    },\n\n    'interactions:destroy': ({ interaction }) => {\n      interaction.autoScroll = null\n      autoScroll.stop()\n      if (autoScroll.interaction) {\n        autoScroll.interaction = null\n      }\n    },\n\n    'interactions:stop': autoScroll.stop,\n\n    'interactions:action-move': (arg: any) => autoScroll.onInteractionMove(arg),\n  },\n}\n\nexport default autoScrollPlugin\n"],"names":["install","defaults","actions","scope","autoScroll","now","phaselessTypes","enabled","container","speed","Date","interaction","x","y","isScrolling","prevTime","margin","start","cancel","i","raf","request","scroll","stop","interactable","element","prepared","name","actionName","options","getContainer","dt","s","scrollBy","getScroll","window","scrollLeft","curScroll","prevScroll","delta","type","target","check","_options$actionName$a","onInteractionMove","_ref","top","right","bottom","pointer","interacting","simulation","left","clientY","innerHeight","rect","domUtils","getElementClientRect","clientX","value","getWindow","body","getScrollSize","scrollWidth","getScrollSizeDelta","_ref2","func","scrollContainer","scrollOptions","curSize","prevSize","autoScrollPlugin","id","_ref3","_ref4","arg"],"mappings":"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"}