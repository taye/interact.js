{"version":3,"file":"Interaction.prod.js","sources":["Interaction.ts"],"sourcesContent":["import * as arr from '@interactjs/utils/arr'\nimport extend from '@interactjs/utils/extend'\nimport hypot from '@interactjs/utils/hypot'\nimport { warnOnce, copyAction } from '@interactjs/utils/misc'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\nimport * as rectUtils from '@interactjs/utils/rect'\n\nimport type {\n  Element,\n  EdgeOptions,\n  PointerEventType,\n  PointerType,\n  FullRect,\n  CoordsSet,\n  ActionName,\n  ActionProps,\n} from '@interactjs/core/types'\n\nimport type { Interactable } from './Interactable'\nimport type { EventPhase } from './InteractEvent'\nimport { InteractEvent } from './InteractEvent'\nimport type { ActionDefaults } from './options'\nimport { PointerInfo } from './PointerInfo'\nimport type { Scope } from './scope'\n\nexport enum _ProxyValues {\n  interactable = '',\n  element = '',\n  prepared = '',\n  pointerIsDown = '',\n  pointerWasMoved = '',\n  _proxy = '',\n}\n\nexport enum _ProxyMethods {\n  start = '',\n  move = '',\n  end = '',\n  stop = '',\n  interacting = '',\n}\n\nexport type PointerArgProps<T extends {} = {}> = {\n  pointer: PointerType\n  event: PointerEventType\n  eventTarget: Node\n  pointerIndex: number\n  pointerInfo: PointerInfo\n  interaction: Interaction<never>\n} & T\n\nexport interface DoPhaseArg<T extends ActionName, P extends EventPhase> {\n  event: PointerEventType\n  phase: EventPhase\n  interaction: Interaction<T>\n  iEvent: InteractEvent<T, P>\n  preEnd?: boolean\n  type?: string\n}\n\nexport type DoAnyPhaseArg = DoPhaseArg<ActionName, EventPhase>\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:new': { interaction: Interaction<ActionName> }\n    'interactions:down': PointerArgProps<{\n      type: 'down'\n    }>\n    'interactions:move': PointerArgProps<{\n      type: 'move'\n      dx: number\n      dy: number\n      duplicate: boolean\n    }>\n    'interactions:up': PointerArgProps<{\n      type: 'up'\n      curEventTarget: EventTarget\n    }>\n    'interactions:cancel': SignalArgs['interactions:up'] & {\n      type: 'cancel'\n      curEventTarget: EventTarget\n    }\n    'interactions:update-pointer': PointerArgProps<{\n      down: boolean\n    }>\n    'interactions:remove-pointer': PointerArgProps\n    'interactions:blur': { interaction: Interaction<never>; event: Event; type: 'blur' }\n    'interactions:before-action-start': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-start': DoAnyPhaseArg\n    'interactions:after-action-start': DoAnyPhaseArg\n    'interactions:before-action-move': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-move': DoAnyPhaseArg\n    'interactions:after-action-move': DoAnyPhaseArg\n    'interactions:before-action-end': Omit<DoAnyPhaseArg, 'iEvent'>\n    'interactions:action-end': DoAnyPhaseArg\n    'interactions:after-action-end': DoAnyPhaseArg\n    'interactions:stop': { interaction: Interaction }\n  }\n}\n\nexport type InteractionProxy<T extends ActionName | null = never> = Pick<\n  Interaction<T>,\n  Exclude<keyof typeof _ProxyValues | keyof typeof _ProxyMethods, '_proxy'>\n>\n\nlet idCounter = 0\n\nexport class Interaction<T extends ActionName | null = ActionName> {\n  /** current interactable being interacted with */\n  interactable: Interactable | null = null\n\n  /** the target element of the interactable */\n  element: Element | null = null\n  rect: FullRect | null = null\n  /** @internal */\n  _rects?: {\n    start: FullRect\n    corrected: FullRect\n    previous: FullRect\n    delta: FullRect\n  }\n  /** @internal */\n  edges: EdgeOptions | null = null\n\n  /** @internal */\n  _scopeFire: Scope['fire']\n\n  // action that's ready to be fired on next move event\n  prepared: ActionProps<T> = {\n    name: null,\n    axis: null,\n    edges: null,\n  }\n\n  pointerType: string\n\n  /** @internal keep track of added pointers */\n  pointers: PointerInfo[] = []\n\n  /** @internal pointerdown/mousedown/touchstart event */\n  downEvent: PointerEventType | null = null\n\n  /** @internal */ downPointer: PointerType = {} as PointerType\n\n  /** @internal */\n  _latestPointer: {\n    pointer: PointerType\n    event: PointerEventType\n    eventTarget: Node\n  } = {\n    pointer: null,\n    event: null,\n    eventTarget: null,\n  }\n\n  /** @internal */ prevEvent: InteractEvent<T, EventPhase> = null\n\n  pointerIsDown = false\n  pointerWasMoved = false\n  /** @internal */ _interacting = false\n  /** @internal */ _ending = false\n  /** @internal */ _stopped = true\n  /** @internal */ _proxy: InteractionProxy<T>\n\n  /** @internal */ simulation = null\n\n  /** @internal */ get pointerMoveTolerance() {\n    return 1\n  }\n\n  doMove = warnOnce(function (this: Interaction, signalArg: any) {\n    this.move(signalArg)\n  }, 'The interaction.doMove() method has been renamed to interaction.move()')\n\n  coords: CoordsSet = {\n    // Starting InteractEvent pointer coordinates\n    start: pointerUtils.newCoords(),\n    // Previous native pointer move event coordinates\n    prev: pointerUtils.newCoords(),\n    // current native pointer move event coordinates\n    cur: pointerUtils.newCoords(),\n    // Change in coordinates and time of the pointer\n    delta: pointerUtils.newCoords(),\n    // pointer velocity\n    velocity: pointerUtils.newCoords(),\n  }\n\n  /** @internal */ readonly _id: number = idCounter++\n\n  constructor({ pointerType, scopeFire }: { pointerType?: string; scopeFire: Scope['fire'] }) {\n    this._scopeFire = scopeFire\n    this.pointerType = pointerType\n\n    const that = this\n\n    this._proxy = {} as InteractionProxy<T>\n\n    for (const key in _ProxyValues) {\n      Object.defineProperty(this._proxy, key, {\n        get() {\n          return that[key]\n        },\n      })\n    }\n\n    for (const key in _ProxyMethods) {\n      Object.defineProperty(this._proxy, key, {\n        value: (...args: any[]) => that[key](...args),\n      })\n    }\n\n    this._scopeFire('interactions:new', { interaction: this })\n  }\n\n  pointerDown(pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:down', {\n      pointer,\n      event,\n      eventTarget,\n      pointerIndex,\n      pointerInfo,\n      type: 'down',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable({\n   *     // disable the default drag start by down->move\n   *     manualStart: true\n   *   })\n   *   // start dragging after the user holds the pointer down\n   *   .on('hold', function (event) {\n   *     var interaction = event.interaction\n   *\n   *     if (!interaction.interacting()) {\n   *       interaction.start({ name: 'drag' },\n   *                         event.interactable,\n   *                         event.currentTarget)\n   *     }\n   * })\n   * ```\n   *\n   * Start an action with the given Interactable and Element as tartgets. The\n   * action must be enabled for the target Interactable and an appropriate\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\n   *\n   * Use it with `interactable.<action>able({ manualStart: false })` to always\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\n   *\n   * @param action - The action to be performed - drag, resize, etc.\n   * @param target - The Interactable to target\n   * @param element - The DOM Element to target\n   * @returns Whether the interaction was successfully started\n   */\n  start<A extends ActionName>(action: ActionProps<A>, interactable: Interactable, element: Element): boolean {\n    if (\n      this.interacting() ||\n      !this.pointerIsDown ||\n      this.pointers.length < (action.name === 'gesture' ? 2 : 1) ||\n      !interactable.options[action.name as keyof ActionDefaults].enabled\n    ) {\n      return false\n    }\n\n    copyAction(this.prepared, action)\n\n    this.interactable = interactable\n    this.element = element\n    this.rect = interactable.getRect(element)\n    this.edges = this.prepared.edges\n      ? extend({}, this.prepared.edges)\n      : { left: true, right: true, top: true, bottom: true }\n    this._stopped = false\n    this._interacting =\n      this._doPhase({\n        interaction: this,\n        event: this.downEvent,\n        phase: 'start',\n      }) && !this._stopped\n\n    return this._interacting\n  }\n\n  pointerMove(pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    if (!this.simulation && !(this.modification && this.modification.endResult)) {\n      this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const duplicateMove =\n      this.coords.cur.page.x === this.coords.prev.page.x &&\n      this.coords.cur.page.y === this.coords.prev.page.y &&\n      this.coords.cur.client.x === this.coords.prev.client.x &&\n      this.coords.cur.client.y === this.coords.prev.client.y\n\n    let dx: number\n    let dy: number\n\n    // register movement greater than pointerMoveTolerance\n    if (this.pointerIsDown && !this.pointerWasMoved) {\n      dx = this.coords.cur.client.x - this.coords.start.client.x\n      dy = this.coords.cur.client.y - this.coords.start.client.y\n\n      this.pointerWasMoved = hypot(dx, dy) > this.pointerMoveTolerance\n    }\n\n    const pointerIndex = this.getPointerIndex(pointer)\n    const signalArg = {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      type: 'move' as const,\n      eventTarget,\n      dx,\n      dy,\n      duplicate: duplicateMove,\n      interaction: this as unknown as Interaction<never>,\n    }\n\n    if (!duplicateMove) {\n      // set pointer coordinate, time changes and velocity\n      pointerUtils.setCoordVelocity(this.coords.velocity, this.coords.delta)\n    }\n\n    this._scopeFire('interactions:move', signalArg)\n\n    if (!duplicateMove && !this.simulation) {\n      // if interacting, fire an 'action-move' signal etc\n      if (this.interacting()) {\n        signalArg.type = null\n        this.move(signalArg)\n      }\n\n      if (this.pointerWasMoved) {\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n      }\n    }\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('dragmove', function (event) {\n   *     if (someCondition) {\n   *       // change the snap settings\n   *       event.interactable.draggable({ snap: { targets: [] }})\n   *       // fire another move event with re-calculated snap\n   *       event.interaction.move()\n   *     }\n   *   })\n   * ```\n   *\n   * Force a move of the current action at the same coordinates. Useful if\n   * snap/restrict has been changed and you want a movement with the new\n   * settings.\n   */\n  move(signalArg?: any) {\n    if (!signalArg || !signalArg.event) {\n      pointerUtils.setZeroCoords(this.coords.delta)\n    }\n\n    signalArg = extend(\n      {\n        pointer: this._latestPointer.pointer,\n        event: this._latestPointer.event,\n        eventTarget: this._latestPointer.eventTarget,\n        interaction: this,\n      },\n      signalArg || {},\n    )\n\n    signalArg.phase = 'move'\n\n    this._doPhase(signalArg)\n  }\n\n  /**\n   * @internal\n   * End interact move events and stop auto-scroll unless simulation is running\n   */\n  pointerUp(pointer: PointerType, event: PointerEventType, eventTarget: Node, curEventTarget: EventTarget) {\n    let pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) {\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\n    }\n\n    const type = /cancel$/i.test(event.type) ? 'cancel' : 'up'\n\n    this._scopeFire(`interactions:${type}` as 'interactions:up' | 'interactions:cancel', {\n      pointer,\n      pointerIndex,\n      pointerInfo: this.pointers[pointerIndex],\n      event,\n      eventTarget,\n      type: type as any,\n      curEventTarget,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    if (!this.simulation) {\n      this.end(event)\n    }\n\n    this.removePointer(pointer, event)\n  }\n\n  /** @internal */\n  documentBlur(event: Event) {\n    this.end(event as any)\n    this._scopeFire('interactions:blur', {\n      event,\n      type: 'blur',\n      interaction: this as unknown as Interaction<never>,\n    })\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   *   .draggable(true)\n   *   .on('move', function (event) {\n   *     if (event.pageX > 1000) {\n   *       // end the current action\n   *       event.interaction.end()\n   *       // stop all further listeners from being called\n   *       event.stopImmediatePropagation()\n   *     }\n   *   })\n   * ```\n   */\n  end(event?: PointerEventType) {\n    this._ending = true\n    event = event || this._latestPointer.event\n    let endPhaseResult: boolean\n\n    if (this.interacting()) {\n      endPhaseResult = this._doPhase({\n        event,\n        interaction: this,\n        phase: 'end',\n      })\n    }\n\n    this._ending = false\n\n    if (endPhaseResult === true) {\n      this.stop()\n    }\n  }\n\n  currentAction() {\n    return this._interacting ? this.prepared.name : null\n  }\n\n  interacting() {\n    return this._interacting\n  }\n\n  stop() {\n    this._scopeFire('interactions:stop', { interaction: this })\n\n    this.interactable = this.element = null\n\n    this._interacting = false\n    this._stopped = true\n    this.prepared.name = this.prevEvent = null\n  }\n\n  /** @internal */\n  getPointerIndex(pointer: any) {\n    const pointerId = pointerUtils.getPointerId(pointer)\n\n    // mouse and pen interactions may have only one pointer\n    return this.pointerType === 'mouse' || this.pointerType === 'pen'\n      ? this.pointers.length - 1\n      : arr.findIndex(this.pointers, (curPointer) => curPointer.id === pointerId)\n  }\n\n  /** @internal */\n  getPointerInfo(pointer: any) {\n    return this.pointers[this.getPointerIndex(pointer)]\n  }\n\n  /** @internal */\n  updatePointer(pointer: PointerType, event: PointerEventType, eventTarget: Node, down?: boolean) {\n    const id = pointerUtils.getPointerId(pointer)\n    let pointerIndex = this.getPointerIndex(pointer)\n    let pointerInfo = this.pointers[pointerIndex]\n\n    down = down === false ? false : down || /(down|start)$/i.test(event.type)\n\n    if (!pointerInfo) {\n      pointerInfo = new PointerInfo(id, pointer, event, null, null)\n\n      pointerIndex = this.pointers.length\n      this.pointers.push(pointerInfo)\n    } else {\n      pointerInfo.pointer = pointer\n    }\n\n    pointerUtils.setCoords(\n      this.coords.cur,\n      this.pointers.map((p) => p.pointer),\n      this._now(),\n    )\n    pointerUtils.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\n\n    if (down) {\n      this.pointerIsDown = true\n\n      pointerInfo.downTime = this.coords.cur.timeStamp\n      pointerInfo.downTarget = eventTarget\n      pointerUtils.pointerExtend(this.downPointer, pointer)\n\n      if (!this.interacting()) {\n        pointerUtils.copyCoords(this.coords.start, this.coords.cur)\n        pointerUtils.copyCoords(this.coords.prev, this.coords.cur)\n\n        this.downEvent = event\n        this.pointerWasMoved = false\n      }\n    }\n\n    this._updateLatestPointer(pointer, event, eventTarget)\n\n    this._scopeFire('interactions:update-pointer', {\n      pointer,\n      event,\n      eventTarget,\n      down,\n      pointerInfo,\n      pointerIndex,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    return pointerIndex\n  }\n\n  /** @internal */\n  removePointer(pointer: PointerType, event: PointerEventType) {\n    const pointerIndex = this.getPointerIndex(pointer)\n\n    if (pointerIndex === -1) return\n\n    const pointerInfo = this.pointers[pointerIndex]\n\n    this._scopeFire('interactions:remove-pointer', {\n      pointer,\n      event,\n      eventTarget: null,\n      pointerIndex,\n      pointerInfo,\n      interaction: this as unknown as Interaction<never>,\n    })\n\n    this.pointers.splice(pointerIndex, 1)\n    this.pointerIsDown = false\n  }\n\n  /** @internal */\n  _updateLatestPointer(pointer: PointerType, event: PointerEventType, eventTarget: Node) {\n    this._latestPointer.pointer = pointer\n    this._latestPointer.event = event\n    this._latestPointer.eventTarget = eventTarget\n  }\n\n  destroy() {\n    this._latestPointer.pointer = null\n    this._latestPointer.event = null\n    this._latestPointer.eventTarget = null\n  }\n\n  /** @internal */\n  _createPreparedEvent<P extends EventPhase>(\n    event: PointerEventType,\n    phase: P,\n    preEnd?: boolean,\n    type?: string,\n  ) {\n    return new InteractEvent<T, P>(this, event, this.prepared.name, phase, this.element, preEnd, type)\n  }\n\n  /** @internal */\n  _fireEvent<P extends EventPhase>(iEvent: InteractEvent<T, P>) {\n    this.interactable?.fire(iEvent)\n\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\n      this.prevEvent = iEvent\n    }\n  }\n\n  /** @internal */\n  _doPhase<P extends EventPhase>(\n    signalArg: Omit<DoPhaseArg<T, P>, 'iEvent'> & { iEvent?: InteractEvent<T, P> },\n  ) {\n    const { event, phase, preEnd, type } = signalArg\n    const { rect } = this\n\n    if (rect && phase === 'move') {\n      // update the rect changes due to pointer move\n      rectUtils.addEdges(this.edges, rect, this.coords.delta[this.interactable.options.deltaSource])\n\n      rect.width = rect.right - rect.left\n      rect.height = rect.bottom - rect.top\n    }\n\n    const beforeResult = this._scopeFire(`interactions:before-action-${phase}` as any, signalArg)\n\n    if (beforeResult === false) {\n      return false\n    }\n\n    const iEvent = (signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type))\n\n    this._scopeFire(`interactions:action-${phase}` as any, signalArg)\n\n    if (phase === 'start') {\n      this.prevEvent = iEvent\n    }\n\n    this._fireEvent(iEvent)\n\n    this._scopeFire(`interactions:after-action-${phase}` as any, signalArg)\n\n    return true\n  }\n\n  /** @internal */\n  _now() {\n    return Date.now()\n  }\n}\n\nexport default Interaction\nexport { PointerInfo }\n"],"names":["_ProxyValues","_ProxyMethods","idCounter","pointerMoveTolerance","interactable","constructor","_ref","rect","element","this","_scopeFire","name","axis","edges","pointers","downEvent","downPointer","event","eventTarget","pointerIsDown","prevEvent","pointerWasMoved","_interacting","_ending","_proxy","_stopped","doMove","warnOnce","signalArg","move","coords","cur","pointerUtils","newCoords","_id","prev","pointerType","scopeFire","delta","velocity","that","Object","defineProperty","key","arguments","get","pointerDown","pointer","pointerIndex","value","pointerInfo","interaction","start","action","interacting","length","options","enabled","copyAction","prepared","getRect","extend","left","right","top","_doPhase","phase","simulation","modification","endResult","bottom","duplicateMove","page","x","y","client","dx","dy","hypot","getPointerIndex","type","duplicate","setCoordVelocity","setZeroCoords","_latestPointer","curEventTarget","updatePointer","test","pointerUp","removePointer","end","endPhaseResult","stop","currentAction","pointerId","getPointerId","arr","findIndex","curPointer","id","getPointerInfo","down","PointerInfo","setCoords","map","p","_now","timeStamp","pointerExtend","copyCoords","splice","_updateLatestPointer","preEnd","destroy","iEvent","_this$interactable","fire","_fireEvent","deltaSource","width","height","Date","now","Interaction"],"mappings":"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"}