{"version":3,"file":"Interactable.prod.js","sources":["Interactable.ts"],"sourcesContent":["/* eslint-disable no-dupe-class-members */\nimport * as arr from '@interactjs/utils/arr'\nimport browser from '@interactjs/utils/browser'\nimport clone from '@interactjs/utils/clone'\nimport { getElementRect, matchesUpTo, nodeContains, trySelector } from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport isNonNativeEvent from '@interactjs/utils/isNonNativeEvent'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport { getWindow } from '@interactjs/utils/window'\n\nimport type { Scope } from '@interactjs/core/scope'\nimport type {\n  ActionMap,\n  ActionMethod,\n  ActionName,\n  Actions,\n  Context,\n  Element,\n  EventTypes,\n  Listeners,\n  ListenersArg,\n  OrBoolean,\n  Target,\n} from '@interactjs/core/types'\n\nimport { Eventable } from './Eventable'\nimport type { ActionDefaults, Defaults, OptionsArg, PerActionDefaults, Options } from './options'\n\ntype IgnoreValue = string | Element | boolean\ntype DeltaSource = 'page' | 'client'\n\nconst enum OnOffMethod {\n  On,\n  Off,\n}\n\n/**\n * ```ts\n * const interactable = interact('.cards')\n *   .draggable({\n *     listeners: { move: event => console.log(event.type, event.pageX, event.pageY) }\n *   })\n *   .resizable({\n *     listeners: { move: event => console.log(event.rect) },\n *     modifiers: [interact.modifiers.restrictEdges({ outer: 'parent' })]\n *   })\n * ```\n */\nexport class Interactable implements Partial<Eventable> {\n  /** @internal */ get _defaults(): Defaults {\n    return {\n      base: {},\n      perAction: {},\n      actions: {} as ActionDefaults,\n    }\n  }\n\n  readonly target: Target\n  /** @internal */ readonly options!: Required<Options>\n  /** @internal */ readonly _actions: Actions\n  /** @internal */ readonly events = new Eventable()\n  /** @internal */ readonly _context: Context\n  /** @internal */ readonly _win: Window\n  /** @internal */ readonly _doc: Document\n  /** @internal */ readonly _scopeEvents: Scope['events']\n\n  constructor(\n    target: Target,\n    options: any,\n    defaultContext: Document | Element,\n    scopeEvents: Scope['events'],\n  ) {\n    this._actions = options.actions\n    this.target = target\n    this._context = options.context || defaultContext\n    this._win = getWindow(trySelector(target) ? this._context : target)\n    this._doc = this._win.document\n    this._scopeEvents = scopeEvents\n\n    this.set(options)\n  }\n\n  setOnEvents(actionName: ActionName, phases: NonNullable<any>) {\n    if (is.func(phases.onstart)) {\n      this.on(`${actionName}start`, phases.onstart)\n    }\n    if (is.func(phases.onmove)) {\n      this.on(`${actionName}move`, phases.onmove)\n    }\n    if (is.func(phases.onend)) {\n      this.on(`${actionName}end`, phases.onend)\n    }\n    if (is.func(phases.oninertiastart)) {\n      this.on(`${actionName}inertiastart`, phases.oninertiastart)\n    }\n\n    return this\n  }\n\n  updatePerActionListeners(actionName: ActionName, prev: Listeners | undefined, cur: Listeners | undefined) {\n    const actionFilter = (this._actions.map[actionName] as { filterEventType?: (type: string) => boolean })\n      ?.filterEventType\n    const filter = (type: string) =>\n      (actionFilter == null || actionFilter(type)) && isNonNativeEvent(type, this._actions)\n\n    if (is.array(prev) || is.object(prev)) {\n      this._onOff(OnOffMethod.Off, actionName, prev, undefined, filter)\n    }\n\n    if (is.array(cur) || is.object(cur)) {\n      this._onOff(OnOffMethod.On, actionName, cur, undefined, filter)\n    }\n  }\n\n  setPerAction(actionName: ActionName, options: OrBoolean<Options>) {\n    const defaults = this._defaults\n\n    // for all the default per-action options\n    for (const optionName_ in options) {\n      const optionName = optionName_ as keyof PerActionDefaults\n      const actionOptions = this.options[actionName]\n      const optionValue: any = options[optionName]\n\n      // remove old event listeners and add new ones\n      if (optionName === 'listeners') {\n        this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue as Listeners)\n      }\n\n      // if the option value is an array\n      if (is.array(optionValue)) {\n        ;(actionOptions[optionName] as any) = arr.from(optionValue)\n      }\n      // if the option value is an object\n      else if (is.plainObject(optionValue)) {\n        // copy the object\n        ;(actionOptions[optionName] as any) = extend(\n          actionOptions[optionName] || ({} as any),\n          clone(optionValue),\n        )\n\n        // set anabled field to true if it exists in the defaults\n        if (\n          is.object(defaults.perAction[optionName]) &&\n          'enabled' in (defaults.perAction[optionName] as any)\n        ) {\n          ;(actionOptions[optionName] as any).enabled = optionValue.enabled !== false\n        }\n      }\n      // if the option value is a boolean and the default is an object\n      else if (is.bool(optionValue) && is.object(defaults.perAction[optionName])) {\n        ;(actionOptions[optionName] as any).enabled = optionValue\n      }\n      // if it's anything else, do a plain assignment\n      else {\n        ;(actionOptions[optionName] as any) = optionValue\n      }\n    }\n  }\n\n  /**\n   * The default function to get an Interactables bounding rect. Can be\n   * overridden using {@link Interactable.rectChecker}.\n   *\n   * @param {Element} [element] The element to measure.\n   * @return {Rect} The object's bounding rectangle.\n   */\n  getRect(element: Element) {\n    element = element || (is.element(this.target) ? this.target : null)\n\n    if (is.string(this.target)) {\n      element = element || this._context.querySelector(this.target)\n    }\n\n    return getElementRect(element)\n  }\n\n  /**\n   * Returns or sets the function used to calculate the interactable's\n   * element's rectangle\n   *\n   * @param {function} [checker] A function which returns this Interactable's\n   * bounding rectangle. See {@link Interactable.getRect}\n   * @return {function | object} The checker function or this Interactable\n   */\n  rectChecker(): (element: Element) => any | null\n  rectChecker(checker: (element: Element) => any): this\n  rectChecker(checker?: (element: Element) => any) {\n    if (is.func(checker)) {\n      this.getRect = (element) => {\n        const rect = extend({}, checker.apply(this, element))\n\n        if (!(('width' in rect) as unknown)) {\n          rect.width = rect.right - rect.left\n          rect.height = rect.bottom - rect.top\n        }\n\n        return rect\n      }\n\n      return this\n    }\n\n    if (checker === null) {\n      delete (this as Partial<typeof this>).getRect\n\n      return this\n    }\n\n    return this.getRect\n  }\n\n  /** @internal */\n  _backCompatOption(optionName: keyof Options, newValue: any) {\n    if (trySelector(newValue) || is.object(newValue)) {\n      ;(this.options[optionName] as any) = newValue\n\n      for (const action in this._actions.map) {\n        ;(this.options[action as keyof ActionMap] as any)[optionName] = newValue\n      }\n\n      return this\n    }\n\n    return this.options[optionName]\n  }\n\n  /**\n   * Gets or sets the origin of the Interactable's element.  The x and y\n   * of the origin will be subtracted from action event coordinates.\n   *\n   * @param {Element | object | string} [origin] An HTML or SVG Element whose\n   * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'\n   * or any CSS selector\n   *\n   * @return {object} The current origin or this Interactable\n   */\n  origin(newValue: any) {\n    return this._backCompatOption('origin', newValue)\n  }\n\n  /**\n   * Returns or sets the mouse coordinate types used to calculate the\n   * movement of the pointer.\n   *\n   * @param {string} [newValue] Use 'client' if you will be scrolling while\n   * interacting; Use 'page' if you want autoScroll to work\n   * @return {string | object} The current deltaSource or this Interactable\n   */\n  deltaSource(): DeltaSource\n  deltaSource(newValue: DeltaSource): this\n  deltaSource(newValue?: DeltaSource) {\n    if (newValue === 'page' || newValue === 'client') {\n      this.options.deltaSource = newValue\n\n      return this\n    }\n\n    return this.options.deltaSource\n  }\n\n  /** @internal */\n  getAllElements(): Element[] {\n    const { target } = this\n\n    if (is.string(target)) {\n      return Array.from(this._context.querySelectorAll(target))\n    }\n\n    if (is.func(target) && (target as any).getAllElements) {\n      return (target as any).getAllElements()\n    }\n\n    return is.element(target) ? [target] : []\n  }\n\n  /**\n   * Gets the selector context Node of the Interactable. The default is\n   * `window.document`.\n   *\n   * @return {Node} The context Node of this Interactable\n   */\n  context() {\n    return this._context\n  }\n\n  inContext(element: Document | Node) {\n    return this._context === element.ownerDocument || nodeContains(this._context, element)\n  }\n\n  /** @internal */\n  testIgnoreAllow(\n    this: Interactable,\n    options: { ignoreFrom?: IgnoreValue; allowFrom?: IgnoreValue },\n    targetNode: Node,\n    eventTarget: Node,\n  ) {\n    return (\n      !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) &&\n      this.testAllow(options.allowFrom, targetNode, eventTarget)\n    )\n  }\n\n  /** @internal */\n  testAllow(this: Interactable, allowFrom: IgnoreValue | undefined, targetNode: Node, element: Node) {\n    if (!allowFrom) {\n      return true\n    }\n\n    if (!is.element(element)) {\n      return false\n    }\n\n    if (is.string(allowFrom)) {\n      return matchesUpTo(element, allowFrom, targetNode)\n    } else if (is.element(allowFrom)) {\n      return nodeContains(allowFrom, element)\n    }\n\n    return false\n  }\n\n  /** @internal */\n  testIgnore(this: Interactable, ignoreFrom: IgnoreValue | undefined, targetNode: Node, element: Node) {\n    if (!ignoreFrom || !is.element(element)) {\n      return false\n    }\n\n    if (is.string(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, targetNode)\n    } else if (is.element(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element)\n    }\n\n    return false\n  }\n\n  /**\n   * Calls listeners for the given InteractEvent type bound globally\n   * and directly to this Interactable\n   *\n   * @param {InteractEvent} iEvent The InteractEvent object to be fired on this\n   * Interactable\n   * @return {Interactable} this Interactable\n   */\n  fire<E extends { type: string }>(iEvent: E) {\n    this.events.fire(iEvent)\n\n    return this\n  }\n\n  /** @internal */\n  _onOff(\n    method: OnOffMethod,\n    typeArg: EventTypes,\n    listenerArg?: ListenersArg | null,\n    options?: any,\n    filter?: (type: string) => boolean,\n  ) {\n    if (is.object(typeArg) && !is.array(typeArg)) {\n      options = listenerArg\n      listenerArg = null\n    }\n\n    const listeners = normalizeListeners(typeArg, listenerArg, filter)\n\n    for (let type in listeners) {\n      if (type === 'wheel') {\n        type = browser.wheelEvent\n      }\n\n      for (const listener of listeners[type]) {\n        // if it is an action event type\n        if (isNonNativeEvent(type, this._actions)) {\n          this.events[method === OnOffMethod.On ? 'on' : 'off'](type, listener)\n        }\n        // delegated event\n        else if (is.string(this.target)) {\n          this._scopeEvents[method === OnOffMethod.On ? 'addDelegate' : 'removeDelegate'](\n            this.target,\n            this._context,\n            type,\n            listener,\n            options,\n          )\n        }\n        // remove listener from this Interactable's element\n        else {\n          this._scopeEvents[method === OnOffMethod.On ? 'add' : 'remove'](\n            this.target,\n            type,\n            listener,\n            options,\n          )\n        }\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Binds a listener for an InteractEvent, pointerEvent or DOM event.\n   *\n   * @param {string | array | object} types The types of events to listen\n   * for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * addEventListener\n   * @return {Interactable} This Interactable\n   */\n  on(types: EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff(OnOffMethod.On, types, listener, options)\n  }\n\n  /**\n   * Removes an InteractEvent, pointerEvent or DOM event listener.\n   *\n   * @param {string | array | object} types The types of events that were\n   * listened for\n   * @param {function | array | object} [listener] The event listener function(s)\n   * @param {object | boolean} [options] options object or useCapture flag for\n   * removeEventListener\n   * @return {Interactable} This Interactable\n   */\n  off(types: string | string[] | EventTypes, listener?: ListenersArg, options?: any) {\n    return this._onOff(OnOffMethod.Off, types, listener, options)\n  }\n\n  /**\n   * Reset the options of this Interactable\n   *\n   * @param {object} options The new settings to apply\n   * @return {object} This Interactable\n   */\n  set(options: OptionsArg) {\n    const defaults = this._defaults\n\n    if (!is.object(options)) {\n      options = {}\n    }\n\n    ;(this.options as Required<Options>) = clone(defaults.base) as Required<Options>\n\n    for (const actionName_ in this._actions.methodDict) {\n      const actionName = actionName_ as ActionName\n      const methodName = this._actions.methodDict[actionName]\n\n      this.options[actionName] = {}\n      this.setPerAction(actionName, extend(extend({}, defaults.perAction), defaults.actions[actionName]))\n      ;(this[methodName] as ActionMethod<unknown>)(options[actionName])\n    }\n\n    for (const setting in options) {\n      if (setting === 'getRect') {\n        this.rectChecker(options.getRect)\n        continue\n      }\n\n      if (is.func((this as any)[setting])) {\n        ;(this as any)[setting](options[setting as keyof typeof options])\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Remove this interactable from the list of interactables and remove it's\n   * action capabilities and event listeners\n   */\n  unset() {\n    if (is.string(this.target)) {\n      // remove delegated events\n      for (const type in this._scopeEvents.delegatedEvents) {\n        const delegated = this._scopeEvents.delegatedEvents[type]\n\n        for (let i = delegated.length - 1; i >= 0; i--) {\n          const { selector, context, listeners } = delegated[i]\n\n          if (selector === this.target && context === this._context) {\n            delegated.splice(i, 1)\n          }\n\n          for (let l = listeners.length - 1; l >= 0; l--) {\n            this._scopeEvents.removeDelegate(\n              this.target,\n              this._context,\n              type,\n              listeners[l][0],\n              listeners[l][1],\n            )\n          }\n        }\n      }\n    } else {\n      this._scopeEvents.remove(this.target, 'all')\n    }\n  }\n}\n"],"names":["OnOffMethod","Interactable","_defaults","base","perAction","actions","target","options","defaultContext","scopeEvents","this","_actions","events","Eventable","_context","_win","_doc","constructor","context","getWindow","trySelector","document","_scopeEvents","set","setOnEvents","actionName","phases","is","func","onstart","on","onmove","onend","oninertiastart","updatePerActionListeners","prev","cur","_this$_actions$map$ac","actionFilter","map","filterEventType","filter","type","isNonNativeEvent","array","object","_onOff","Off","undefined","On","setPerAction","defaults","optionName_","optionName","actionOptions","optionValue","listeners","arr","from","plainObject","extend","clone","enabled","bool","getRect","element","string","querySelector","getElementRect","rectChecker","checker","rect","apply","width","right","left","height","bottom","top","_backCompatOption","newValue","action","origin","deltaSource","getAllElements","Array","querySelectorAll","inContext","ownerDocument","nodeContains","testIgnoreAllow","targetNode","eventTarget","testIgnore","ignoreFrom","testAllow","allowFrom","matchesUpTo","fire","iEvent","method","typeArg","listenerArg","normalizeListeners","browser","wheelEvent","listener","types","off","actionName_","methodDict","methodName","setting","unset","delegatedEvents","delegated","i","length","selector","splice","l","removeDelegate","remove"],"mappings":"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"}