{"version":3,"file":"InteractableMethods.prod.js","sources":["InteractableMethods.ts"],"sourcesContent":["import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { ActionProps, PointerType, PointerEventType, Element } from '@interactjs/core/types'\nimport is from '@interactjs/utils/is'\nimport { warnOnce } from '@interactjs/utils/misc'\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    getAction: (\n      this: Interactable,\n      pointer: PointerType,\n      event: PointerEventType,\n      interaction: Interaction,\n      element: Element,\n    ) => ActionProps | null\n    styleCursor(newValue: boolean): this\n    styleCursor(): boolean\n    /**\n     * Returns or sets whether the the cursor should be changed depending on the\n     * action that would be performed if the mouse were pressed and dragged.\n     *\n     * @param {boolean} [newValue]\n     * @return {boolean | Interactable} The current setting or this Interactable\n     */\n    styleCursor(newValue?: boolean): boolean | this\n    actionChecker(checker: Function): Interactable\n    actionChecker(): Function\n    /**\n     * ```js\n     * interact('.resize-drag')\n     *   .resizable(true)\n     *   .draggable(true)\n     *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n     *\n     *     if (interact.matchesSelector(event.target, '.drag-handle')) {\n     *       // force drag with handle target\n     *       action.name = drag\n     *     }\n     *     else {\n     *       // resize from the top and right edges\n     *       action.name  = 'resize'\n     *       action.edges = { top: true, right: true }\n     *     }\n     *\n     *     return action\n     * })\n     * ```\n     *\n     * Returns or sets the function used to check action to be performed on\n     * pointerDown\n     *\n     * @param checker - A function which takes a pointer event,\n     * defaultAction string, interactable, element and interaction as parameters\n     * and returns an object with name property 'drag' 'resize' or 'gesture' and\n     * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right\n     * props.\n     * @returns The checker function or this Interactable\n     */\n    actionChecker(checker?: Function): Interactable | Function\n    /** @returns This interactable */\n    ignoreFrom(newValue: string | Element | null): Interactable\n    /** @returns The current ignoreFrom value */\n    ignoreFrom(): string | Element | null\n    /**\n     * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any\n     * of it's parents match the given CSS selector or Element, no\n     * drag/resize/gesture is started.\n     *\n     * @deprecated\n     * Don't use this method. Instead set the `ignoreFrom` option for each action\n     * or for `pointerEvents`\n     *\n     * ```js\n     * interact(targett)\n     *   .draggable({\n     *     ignoreFrom: 'input, textarea, a[href]'',\n     *   })\n     *   .pointerEvents({\n     *     ignoreFrom: '[no-pointer]',\n     *   })\n     * ```\n     * Interactable\n     */\n    ignoreFrom(\n      /** a CSS selector string, an Element or `null` to not ignore any elements */\n      newValue?: string | Element | null,\n    ): Interactable | string | Element | null\n    allowFrom(): boolean\n    /**\n     *\n     * A drag/resize/gesture is started only If the target of the `mousedown`,\n     * `pointerdown` or `touchstart` event or any of it's parents match the given\n     * CSS selector or Element.\n     *\n     * @deprecated\n     * Don't use this method. Instead set the `allowFrom` option for each action\n     * or for `pointerEvents`\n     *\n     * ```js\n     * interact(targett)\n     *   .resizable({\n     *     allowFrom: '.resize-handle',\n     *   .pointerEvents({\n     *     allowFrom: '.handle',,\n     *   })\n     * ```\n     *\n     * @param {string | Element | null} [newValue]\n     * @return {string | Element | object} The current allowFrom value or this\n     * Interactable\n     */\n    allowFrom(\n      /** A CSS selector string, an Element or `null` to allow from any element */\n      newValue: string | Element | null,\n    ): Interactable\n  }\n}\n\nfunction install(scope: Scope) {\n  const {\n    Interactable, // tslint:disable-line no-shadowed-variable\n  } = scope\n\n  Interactable.prototype.getAction = function getAction(\n    this: Interactable,\n    pointer: PointerType,\n    event: PointerEventType,\n    interaction: Interaction,\n    element: Element,\n  ): ActionProps {\n    const action = defaultActionChecker(this, event, interaction, element, scope)\n\n    if (this.options.actionChecker) {\n      return this.options.actionChecker(pointer, event, action, this, element, interaction)\n    }\n\n    return action\n  }\n\n  Interactable.prototype.ignoreFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('ignoreFrom', newValue)\n  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).')\n\n  Interactable.prototype.allowFrom = warnOnce(function (this: Interactable, newValue) {\n    return this._backCompatOption('allowFrom', newValue)\n  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).')\n\n  Interactable.prototype.actionChecker = actionChecker\n\n  Interactable.prototype.styleCursor = styleCursor\n}\n\nfunction defaultActionChecker(\n  interactable: Interactable,\n  event: PointerEventType,\n  interaction: Interaction,\n  element: Element,\n  scope: Scope,\n) {\n  const rect = interactable.getRect(element)\n  const buttons =\n    (event as MouseEvent).buttons ||\n    {\n      0: 1,\n      1: 4,\n      3: 8,\n      4: 16,\n    }[(event as MouseEvent).button as 0 | 1 | 3 | 4]\n  const arg = {\n    action: null,\n    interactable,\n    interaction,\n    element,\n    rect,\n    buttons,\n  }\n\n  scope.fire('auto-start:check', arg)\n\n  return arg.action\n}\n\nfunction styleCursor(this: Interactable, newValue?: boolean) {\n  if (is.bool(newValue)) {\n    this.options.styleCursor = newValue\n\n    return this\n  }\n\n  if (newValue === null) {\n    delete this.options.styleCursor\n\n    return this\n  }\n\n  return this.options.styleCursor\n}\n\nfunction actionChecker(this: Interactable, checker?: any) {\n  if (is.func(checker)) {\n    this.options.actionChecker = checker\n\n    return this\n  }\n\n  if (checker === null) {\n    delete this.options.actionChecker\n\n    return this\n  }\n\n  return this.options.actionChecker\n}\n\nexport default {\n  id: 'auto-start/interactableMethods',\n  install,\n}\n"],"names":["install","Interactable","scope","prototype","getAction","pointer","event","interaction","element","action","defaultActionChecker","options","this","ignoreFrom","warnOnce","newValue","allowFrom","actionChecker","styleCursor","interactable","button","rect","fire","arg","bool","checker","func","InteractableMethods","id"],"mappings":";;oGAuHSA,MAAAA,aACDC,GACQC,EACbD,EAAQE,UAAAC,UAAA,SAAAC,EAAAC,EAAAC,EAAAC,WAEIL,qBAA+BC,KAAAA,EAAAA,EAGnBI,EACCN,GAGxB,OAAMO,KAAAA,QAASC,cAENC,KAAOA,sBAAgBN,EAAAC,EAAAG,EAAAG,KAAAJ,EAAAD,GAEhCE,CAEA,IACDN,UAAAU,WAAAC,UAAA,SAAAC,GAEDd,OAAAA,KAAaE,kBAAUU,aAAoDE,EACzE,GAAA,qGACDd,EAAqGE,UAAAa,UAAAF,UAAA,SAAAC,GAEtGd,OAAAA,KAAaE,kBAAmB,YAA0CY,EACxE,GAAA,mGACDd,EAAmGE,UAAAc,cAAAA,cAEpGhB,EAAaE,UAAUc,YAAaC,WAEpCjB,CACF,SAAAS,qBAAAS,EAAAb,EAAAC,EAAAC,EAAAN,GAESQ,MAAAA,EAAAA,EAAAA,QACPS,GAcKb,EAAqBc,CAC1BX,OAAY,KACVA,eACAU,cACAZ,UACAC,OACAa,QAdWF,EAAAA,SAAoB,KAI7B,EAAG,EACH,EAAG,EACH,EAAG,IACHb,EAAGc,SAWPlB,SAFCoB,KAAA,mBAAAC,GAESA,EAACd,OAGb,SAAAS,YAAAH,GAESG,OAAAA,GAAAA,KAAAA,SACAM,QAAKT,YAAWA,EAChBJ,MAGP,OAAAI,UAEIA,KAAaJ,QAAMO,YACdN,MAGTA,KAAAD,QAAAO,WAEA,CACF,SAAAD,cAAAQ,GAESR,OAAAA,GAAAA,KAAAA,SACAS,QAAKD,cAAUA,EACfd,MAGP,OAAAc,UAEIA,KAAYd,QAAMM,cACbL,MAGTA,KAAAD,QAAAM,aAEA,CACF,IAAAU,oBAAA,CAEeC,GAAA,iCACbA,wBAEDD"}