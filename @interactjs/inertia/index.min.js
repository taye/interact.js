import t from"../modifiers/Modification.min.js";import*as i from"../modifiers/base.min.js";import e from"../offset/index.min.js";import*as s from"../utils/domUtils.min.js";import n from"../utils/hypot.min.js";import*as r from"../utils/is.min.js";import{copyCoords as o}from"../utils/pointerUtils.min.js";import a from"../utils/raf.min.js";export class InertiaState{constructor(t){this.active=!1,this.isModified=!1,this.smoothEnd=!1,this.allowResume=!1,this.modification=null,this.modifierCount=0,this.modifierArg=null,this.startCoords=null,this.t0=0,this.v0=0,this.te=0,this.targetOffset=null,this.modifiedOffset=null,this.currentOffset=null,this.lambda_v0=0,this.one_ve_v0=0,this.timeout=null,this.interaction=void 0,this.interaction=t}start(i){const{interaction:e}=this,s=f(e);if(!s||!s.enabled)return!1;const{client:r}=e.coords.velocity,o=n(r.x,r.y),a=this.modification||(this.modification=new t(e));if(a.copyFrom(e.modification),this.t0=e._now(),this.allowResume=s.allowResume,this.v0=o,this.currentOffset={x:0,y:0},this.startCoords=e.coords.cur.page,this.modifierArg={interaction:e,interactable:e.interactable,element:e.element,rect:e.rect,edges:e.edges,pageCoords:this.startCoords,preEnd:!0,phase:"inertiastart"},this.t0-e.coords.cur.timeStamp<50&&o>s.minSpeed&&o>s.endSpeed)this.startInertia();else{if(a.result=a.setAll(this.modifierArg),!a.result.changed)return!1;this.startSmoothEnd()}return e.modification.result.rect=null,e.offsetBy(this.targetOffset),e._doPhase({interaction:e,event:i,phase:"inertiastart"}),e.offsetBy({x:-this.targetOffset.x,y:-this.targetOffset.y}),e.modification.result.rect=null,this.active=!0,e.simulation=this,!0}startInertia(){const t=this.interaction.coords.velocity.client,i=f(this.interaction),e=i.resistance,s=-Math.log(i.endSpeed/this.v0)/e;this.targetOffset={x:(t.x-s)/e,y:(t.y-s)/e},this.te=s,this.lambda_v0=e/this.v0,this.one_ve_v0=1-i.endSpeed/this.v0;const{modification:n,modifierArg:r}=this;r.pageCoords={x:this.startCoords.x+this.targetOffset.x,y:this.startCoords.y+this.targetOffset.y},n.result=n.setAll(r),n.result.changed&&(this.isModified=!0,this.modifiedOffset={x:this.targetOffset.x+n.result.delta.x,y:this.targetOffset.y+n.result.delta.y}),this.timeout=a.request(()=>this.inertiaTick())}startSmoothEnd(){this.smoothEnd=!0,this.isModified=!0,this.targetOffset={x:this.modification.result.delta.x,y:this.modification.result.delta.y},this.timeout=a.request(()=>this.smoothEndTick())}inertiaTick(){const{interaction:t}=this,i=f(t).resistance,e=(t._now()-this.t0)/1e3;if(e<this.te){const f=1-(Math.exp(-i*e)-this.lambda_v0)/this.one_ve_v0;let u;this.isModified?(s=0,n=0,r=this.targetOffset.x,o=this.targetOffset.y,c=this.modifiedOffset.x,d=this.modifiedOffset.y,u={x:h(m=f,s,r,c),y:h(m,n,o,d)}):u={x:this.targetOffset.x*f,y:this.targetOffset.y*f};const l={x:u.x-this.currentOffset.x,y:u.y-this.currentOffset.y};this.currentOffset.x+=l.x,this.currentOffset.y+=l.y,t.offsetBy(l),t.move(),this.timeout=a.request(()=>this.inertiaTick())}else t.offsetBy({x:this.modifiedOffset.x-this.currentOffset.x,y:this.modifiedOffset.y-this.currentOffset.y}),this.end();var s,n,r,o,c,d,m}smoothEndTick(){const{interaction:t}=this,i=t._now()-this.t0,{smoothEndDuration:e}=f(t);if(i<e){const s={x:d(i,0,this.targetOffset.x,e),y:d(i,0,this.targetOffset.y,e)},n={x:s.x-this.currentOffset.x,y:s.y-this.currentOffset.y};this.currentOffset.x+=n.x,this.currentOffset.y+=n.y,t.offsetBy(n),t.move({skipModifiers:this.modifierCount}),this.timeout=a.request(()=>this.smoothEndTick())}else t.offsetBy({x:this.targetOffset.x-this.currentOffset.x,y:this.targetOffset.y-this.currentOffset.y}),this.end()}resume({pointer:t,event:i,eventTarget:e}){const{interaction:s}=this;s.offsetBy({x:-this.currentOffset.x,y:-this.currentOffset.y}),s.updatePointer(t,i,e,!0),s._doPhase({interaction:s,event:i,phase:"resume"}),o(s.coords.prev,s.coords.cur),this.stop()}end(){this.interaction.move(),this.interaction.end(),this.stop()}stop(){this.active=this.smoothEnd=!1,this.interaction.simulation=null,a.cancel(this.timeout)}}function f({interactable:t,prepared:i}){return t&&t.options&&i.name&&t.options[i.name].inertia}const c={id:"inertia",before:["modifiers/base"],install(t){const{defaults:s}=t;t.usePlugin(e),t.usePlugin(i.default),t.actions.phases.inertiastart=!0,t.actions.phases.resume=!0,s.perAction.inertia={enabled:!1,resistance:10,minSpeed:100,endSpeed:10,allowResume:!0,smoothEndDuration:300}},listeners:{"interactions:new"({interaction:t}){t.inertia=new InertiaState(t)},"interactions:before-action-end"({interaction:t,event:i}){return(!t._interacting||t.simulation||!t.inertia.start(i))&&null},"interactions:down"(t){const{interaction:i,eventTarget:e}=t,n=i.inertia;if(!n.active)return;let o=e;for(;r.element(o);){if(o===i.element){n.resume(t);break}o=s.parentNode(o)}},"interactions:stop"({interaction:t}){const i=t.inertia;i.active&&i.stop()},"interactions:before-action-resume"(t){const{modification:i}=t.interaction;i.stop(t),i.start(t,t.interaction.coords.cur.page),i.applyToInteraction(t)},"interactions:before-action-inertiastart"(t){return t.interaction.modification.setAndApply(t)},"interactions:action-resume":i.addEventModifiers,"interactions:action-inertiastart":i.addEventModifiers,"interactions:after-action-inertiastart"(t){return t.interaction.modification.restoreInteractionCoords(t)},"interactions:after-action-resume"(t){return t.interaction.modification.restoreInteractionCoords(t)}}};function h(t,i,e,s){const n=1-t;return n*n*i+2*n*t*e+t*t*s}function d(t,i,e,s){return-e*(t/=s)*(t-2)+i}export default c;
//# sourceMappingURL=index.min.js.map