{"version":3,"file":"events.prod.js","sources":["events.ts"],"sourcesContent":["import * as arr from '@interactjs/utils/arr'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport is from '@interactjs/utils/is'\nimport pExtend from '@interactjs/utils/pointerExtend'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\nimport type { Scope } from '@interactjs/core/scope'\nimport type { Element } from '@interactjs/core/types'\n\nimport type { NativeEventTarget } from './NativeTypes'\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    events: ReturnType<typeof install>\n  }\n}\n\ninterface EventOptions {\n  capture: boolean\n  passive: boolean\n}\n\ntype PartialEventTarget = Partial<NativeEventTarget>\n\ntype ListenerEntry = { func: (event: Event | FakeEvent) => any; options: EventOptions }\n\nfunction install(scope: Scope) {\n  const targets: Array<{\n    eventTarget: PartialEventTarget\n    events: { [type: string]: ListenerEntry[] }\n  }> = []\n\n  const delegatedEvents: {\n    [type: string]: Array<{\n      selector: string\n      context: Node\n      listeners: ListenerEntry[]\n    }>\n  } = {}\n  const documents: Document[] = []\n\n  const eventsMethods = {\n    add,\n    remove,\n\n    addDelegate,\n    removeDelegate,\n\n    delegateListener,\n    delegateUseCapture,\n    delegatedEvents,\n    documents,\n\n    targets,\n\n    supportsOptions: false,\n    supportsPassive: false,\n  }\n\n  // check if browser supports passive events and options arg\n  scope.document?.createElement('div').addEventListener('test', null, {\n    get capture() {\n      return (eventsMethods.supportsOptions = true)\n    },\n    get passive() {\n      return (eventsMethods.supportsPassive = true)\n    },\n  })\n\n  scope.events = eventsMethods\n\n  function add(\n    eventTarget: PartialEventTarget,\n    type: string,\n    listener: ListenerEntry['func'],\n    optionalArg?: boolean | EventOptions,\n  ) {\n    if (!eventTarget.addEventListener) return\n\n    const options = getOptions(optionalArg)\n    let target = arr.find(targets, (t) => t.eventTarget === eventTarget)\n\n    if (!target) {\n      target = {\n        eventTarget,\n        events: {},\n      }\n\n      targets.push(target)\n    }\n\n    if (!target.events[type]) {\n      target.events[type] = []\n    }\n\n    if (!arr.find(target.events[type], (l) => l.func === listener && optionsMatch(l.options, options))) {\n      eventTarget.addEventListener(\n        type,\n        listener as any,\n        eventsMethods.supportsOptions ? options : options.capture,\n      )\n      target.events[type].push({ func: listener, options })\n    }\n  }\n\n  function remove(\n    eventTarget: PartialEventTarget,\n    type: string,\n    listener?: 'all' | ListenerEntry['func'],\n    optionalArg?: boolean | EventOptions,\n  ) {\n    if (!eventTarget.addEventListener || !eventTarget.removeEventListener) return\n\n    const targetIndex = arr.findIndex(targets, (t) => t.eventTarget === eventTarget)\n    const target = targets[targetIndex]\n\n    if (!target || !target.events) {\n      return\n    }\n\n    if (type === 'all') {\n      for (type in target.events) {\n        if (target.events.hasOwnProperty(type)) {\n          remove(eventTarget, type, 'all')\n        }\n      }\n      return\n    }\n\n    let typeIsEmpty = false\n    const typeListeners = target.events[type]\n\n    if (typeListeners) {\n      if (listener === 'all') {\n        for (let i = typeListeners.length - 1; i >= 0; i--) {\n          const entry = typeListeners[i]\n          remove(eventTarget, type, entry.func, entry.options)\n        }\n        return\n      } else {\n        const options = getOptions(optionalArg)\n\n        for (let i = 0; i < typeListeners.length; i++) {\n          const entry = typeListeners[i]\n          if (entry.func === listener && optionsMatch(entry.options, options)) {\n            eventTarget.removeEventListener(\n              type,\n              listener as any,\n              eventsMethods.supportsOptions ? options : options.capture,\n            )\n            typeListeners.splice(i, 1)\n\n            if (typeListeners.length === 0) {\n              delete target.events[type]\n              typeIsEmpty = true\n            }\n\n            break\n          }\n        }\n      }\n    }\n\n    if (typeIsEmpty && !Object.keys(target.events).length) {\n      targets.splice(targetIndex, 1)\n    }\n  }\n\n  function addDelegate(\n    selector: string,\n    context: Node,\n    type: string,\n    listener: ListenerEntry['func'],\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    if (!delegatedEvents[type]) {\n      delegatedEvents[type] = []\n\n      // add delegate listener functions\n      for (const doc of documents) {\n        add(doc, type, delegateListener)\n        add(doc, type, delegateUseCapture, true)\n      }\n    }\n\n    const delegates = delegatedEvents[type]\n    let delegate = arr.find(delegates, (d) => d.selector === selector && d.context === context)\n\n    if (!delegate) {\n      delegate = { selector, context, listeners: [] }\n      delegates.push(delegate)\n    }\n\n    delegate.listeners.push({ func: listener, options })\n  }\n\n  function removeDelegate(\n    selector: string,\n    context: Document | Element,\n    type: string,\n    listener?: ListenerEntry['func'],\n    optionalArg?: any,\n  ) {\n    const options = getOptions(optionalArg)\n    const delegates = delegatedEvents[type]\n    let matchFound = false\n    let index: number\n\n    if (!delegates) return\n\n    // count from last index of delegated to 0\n    for (index = delegates.length - 1; index >= 0; index--) {\n      const cur = delegates[index]\n      // look for matching selector and context Node\n      if (cur.selector === selector && cur.context === context) {\n        const { listeners } = cur\n\n        // each item of the listeners array is an array: [function, capture, passive]\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          const entry = listeners[i]\n\n          // check if the listener functions and capture and passive flags match\n          if (entry.func === listener && optionsMatch(entry.options, options)) {\n            // remove the listener from the array of listeners\n            listeners.splice(i, 1)\n\n            // if all listeners for this target have been removed\n            // remove the target from the delegates array\n            if (!listeners.length) {\n              delegates.splice(index, 1)\n\n              // remove delegate function from context\n              remove(context, type, delegateListener)\n              remove(context, type, delegateUseCapture, true)\n            }\n\n            // only remove one listener\n            matchFound = true\n            break\n          }\n        }\n\n        if (matchFound) {\n          break\n        }\n      }\n    }\n  }\n\n  // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n  function delegateListener(event: Event | FakeEvent, optionalArg?: any) {\n    const options = getOptions(optionalArg)\n    const fakeEvent = new FakeEvent(event as Event)\n    const delegates = delegatedEvents[event.type]\n    const [eventTarget] = pointerUtils.getEventTargets(event as Event)\n    let element: Node = eventTarget\n\n    // climb up document tree looking for selector matches\n    while (is.element(element)) {\n      for (let i = 0; i < delegates.length; i++) {\n        const cur = delegates[i]\n        const { selector, context } = cur\n\n        if (\n          domUtils.matchesSelector(element, selector) &&\n          domUtils.nodeContains(context, eventTarget) &&\n          domUtils.nodeContains(context, element)\n        ) {\n          const { listeners } = cur\n\n          fakeEvent.currentTarget = element\n\n          for (const entry of listeners) {\n            if (optionsMatch(entry.options, options)) {\n              entry.func(fakeEvent)\n            }\n          }\n        }\n      }\n\n      element = domUtils.parentNode(element)\n    }\n  }\n\n  function delegateUseCapture(this: Element, event: Event | FakeEvent) {\n    return delegateListener.call(this, event, true)\n  }\n\n  // for type inferrence\n  return eventsMethods\n}\n\nclass FakeEvent implements Partial<Event> {\n  currentTarget: Node\n  originalEvent: Event\n  type: string\n\n  constructor(originalEvent: Event) {\n    this.originalEvent = originalEvent\n    // duplicate the event so that currentTarget can be changed\n    pExtend(this, originalEvent)\n  }\n\n  preventOriginalDefault() {\n    this.originalEvent.preventDefault()\n  }\n\n  stopPropagation() {\n    this.originalEvent.stopPropagation()\n  }\n\n  stopImmediatePropagation() {\n    this.originalEvent.stopImmediatePropagation()\n  }\n}\n\nfunction getOptions(param: { [index: string]: any } | boolean): { capture: boolean; passive: boolean } {\n  if (!is.object(param)) {\n    return { capture: !!param, passive: false }\n  }\n\n  return {\n    capture: !!param.capture,\n    passive: !!param.passive,\n  }\n}\n\nfunction optionsMatch(a: Partial<EventOptions> | boolean, b: Partial<EventOptions>) {\n  if (a === b) return true\n\n  if (typeof a === 'boolean') return !!b.capture === a && !!b.passive === false\n\n  return !!a.capture === !!b.capture && !!a.passive === !!b.passive\n}\n\nexport default {\n  id: 'events',\n  install,\n}\n"],"names":["install","targets","delegatedEvents","documents","add","remove","selector","context","type","listener","optionalArg","addDelegate","doc","delegateListener","delegates","arr","d","delegate","push","listeners","func","removeDelegate","options","matchFound","index","length","cur","i","entry","optionsMatch","splice","delegateUseCapture","supportsOptions","scope","eventTarget","addEventListener","getOptions","target","events","find","l","eventsMethods","capture","t","removeEventListener","targetIndex","typeIsEmpty","typeListeners","Object","keys","event","fakeEvent","getEventTargets","element","is","matchesSelector","domUtils","nodeContains","currentTarget","parentNode","_scope$document","document","createElement","passive","supportsPassive","FakeEvent","constructor","originalEvent","pExtend","this","preventOriginalDefault","stopPropagation","stopImmediatePropagation","param","a","b","id"],"mappings":"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"}