{"version":3,"file":"plugin.prod.js","sources":["plugin.ts"],"sourcesContent":["import type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type { ActionName, Point, PointerEventType } from '@interactjs/core/types'\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport '@interactjs/modifiers/base'\nimport '@interactjs/offset/plugin'\nimport * as modifiers from '@interactjs/modifiers/base'\nimport { Modification } from '@interactjs/modifiers/Modification'\nimport type { ModifierArg } from '@interactjs/modifiers/types'\nimport offset from '@interactjs/offset/plugin'\n/* eslint-enable import/no-duplicates */\nimport * as dom from '@interactjs/utils/domUtils'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { copyCoords } from '@interactjs/utils/pointerUtils'\nimport raf from '@interactjs/utils/raf'\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface PhaseMap {\n    resume?: true\n    inertiastart?: true\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    inertia?: InertiaState\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface PerActionDefaults {\n    inertia?: {\n      enabled?: boolean\n      resistance?: number // the lambda in exponential decay\n      minSpeed?: number // target speed must be above this for inertia to start\n      endSpeed?: number // the speed at which inertia is slow enough to stop\n      allowResume?: true // allow resuming an action in inertia phase\n      smoothEndDuration?: number // animate to snap/restrict endOnly if there's no inertia\n    }\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'interactions:before-action-inertiastart': Omit<DoPhaseArg<ActionName, 'inertiastart'>, 'iEvent'>\n    'interactions:action-inertiastart': DoPhaseArg<ActionName, 'inertiastart'>\n    'interactions:after-action-inertiastart': DoPhaseArg<ActionName, 'inertiastart'>\n    'interactions:before-action-resume': Omit<DoPhaseArg<ActionName, 'resume'>, 'iEvent'>\n    'interactions:action-resume': DoPhaseArg<ActionName, 'resume'>\n    'interactions:after-action-resume': DoPhaseArg<ActionName, 'resume'>\n  }\n}\n\nfunction install(scope: Scope) {\n  const { defaults } = scope\n\n  scope.usePlugin(offset)\n  scope.usePlugin(modifiers.default)\n  scope.actions.phases.inertiastart = true\n  scope.actions.phases.resume = true\n\n  defaults.perAction.inertia = {\n    enabled: false,\n    resistance: 10, // the lambda in exponential decay\n    minSpeed: 100, // target speed must be above this for inertia to start\n    endSpeed: 10, // the speed at which inertia is slow enough to stop\n    allowResume: true, // allow resuming an action in inertia phase\n    smoothEndDuration: 300, // animate to snap/restrict endOnly if there's no inertia\n  }\n}\n\nexport class InertiaState {\n  active = false\n  isModified = false\n  smoothEnd = false\n  allowResume = false\n\n  modification!: Modification\n  modifierCount = 0\n  modifierArg!: ModifierArg\n\n  startCoords!: Point\n  t0 = 0\n  v0 = 0\n\n  te = 0\n  targetOffset!: Point\n  modifiedOffset!: Point\n  currentOffset!: Point\n\n  lambda_v0? = 0 // eslint-disable-line camelcase\n  one_ve_v0? = 0 // eslint-disable-line camelcase\n  timeout!: number\n  readonly interaction: Interaction\n\n  constructor(interaction: Interaction) {\n    this.interaction = interaction\n  }\n\n  start(event: PointerEventType) {\n    const { interaction } = this\n    const options = getOptions(interaction)\n\n    if (!options || !options.enabled) {\n      return false\n    }\n\n    const { client: velocityClient } = interaction.coords.velocity\n    const pointerSpeed = hypot(velocityClient.x, velocityClient.y)\n    const modification = this.modification || (this.modification = new Modification(interaction))\n\n    modification.copyFrom(interaction.modification)\n\n    this.t0 = interaction._now()\n    this.allowResume = options.allowResume\n    this.v0 = pointerSpeed\n    this.currentOffset = { x: 0, y: 0 }\n    this.startCoords = interaction.coords.cur.page\n\n    this.modifierArg = modification.fillArg({\n      pageCoords: this.startCoords,\n      preEnd: true,\n      phase: 'inertiastart',\n    })\n\n    const thrown =\n      this.t0 - interaction.coords.cur.timeStamp < 50 &&\n      pointerSpeed > options.minSpeed &&\n      pointerSpeed > options.endSpeed\n\n    if (thrown) {\n      this.startInertia()\n    } else {\n      modification.result = modification.setAll(this.modifierArg)\n\n      if (!modification.result.changed) {\n        return false\n      }\n\n      this.startSmoothEnd()\n    }\n\n    // force modification change\n    interaction.modification.result.rect = null\n\n    // bring inertiastart event to the target coords\n    interaction.offsetBy(this.targetOffset)\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'inertiastart',\n    })\n    interaction.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y })\n    // force modification change\n    interaction.modification.result.rect = null\n\n    this.active = true\n    interaction.simulation = this\n\n    return true\n  }\n\n  startInertia() {\n    const startVelocity = this.interaction.coords.velocity.client\n    const options = getOptions(this.interaction)\n    const lambda = options.resistance\n    const inertiaDur = -Math.log(options.endSpeed / this.v0) / lambda\n\n    this.targetOffset = {\n      x: (startVelocity.x - inertiaDur) / lambda,\n      y: (startVelocity.y - inertiaDur) / lambda,\n    }\n\n    this.te = inertiaDur\n    this.lambda_v0 = lambda / this.v0\n    this.one_ve_v0 = 1 - options.endSpeed / this.v0\n\n    const { modification, modifierArg } = this\n\n    modifierArg.pageCoords = {\n      x: this.startCoords.x + this.targetOffset.x,\n      y: this.startCoords.y + this.targetOffset.y,\n    }\n\n    modification.result = modification.setAll(modifierArg)\n\n    if (modification.result.changed) {\n      this.isModified = true\n      this.modifiedOffset = {\n        x: this.targetOffset.x + modification.result.delta.x,\n        y: this.targetOffset.y + modification.result.delta.y,\n      }\n    }\n\n    this.onNextFrame(() => this.inertiaTick())\n  }\n\n  startSmoothEnd() {\n    this.smoothEnd = true\n    this.isModified = true\n    this.targetOffset = {\n      x: this.modification.result.delta.x,\n      y: this.modification.result.delta.y,\n    }\n\n    this.onNextFrame(() => this.smoothEndTick())\n  }\n\n  onNextFrame(tickFn: () => void) {\n    this.timeout = raf.request(() => {\n      if (this.active) {\n        tickFn()\n      }\n    })\n  }\n\n  inertiaTick() {\n    const { interaction } = this\n    const options = getOptions(interaction)\n    const lambda = options.resistance\n    const t = (interaction._now() - this.t0) / 1000\n\n    if (t < this.te) {\n      const progress = 1 - (Math.exp(-lambda * t) - this.lambda_v0) / this.one_ve_v0\n      let newOffset: Point\n\n      if (this.isModified) {\n        newOffset = getQuadraticCurvePoint(\n          0,\n          0,\n          this.targetOffset.x,\n          this.targetOffset.y,\n          this.modifiedOffset.x,\n          this.modifiedOffset.y,\n          progress,\n        )\n      } else {\n        newOffset = {\n          x: this.targetOffset.x * progress,\n          y: this.targetOffset.y * progress,\n        }\n      }\n\n      const delta = { x: newOffset.x - this.currentOffset.x, y: newOffset.y - this.currentOffset.y }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move()\n\n      this.onNextFrame(() => this.inertiaTick())\n    } else {\n      interaction.offsetBy({\n        x: this.modifiedOffset.x - this.currentOffset.x,\n        y: this.modifiedOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  smoothEndTick() {\n    const { interaction } = this\n    const t = interaction._now() - this.t0\n    const { smoothEndDuration: duration } = getOptions(interaction)\n\n    if (t < duration) {\n      const newOffset = {\n        x: easeOutQuad(t, 0, this.targetOffset.x, duration),\n        y: easeOutQuad(t, 0, this.targetOffset.y, duration),\n      }\n      const delta = {\n        x: newOffset.x - this.currentOffset.x,\n        y: newOffset.y - this.currentOffset.y,\n      }\n\n      this.currentOffset.x += delta.x\n      this.currentOffset.y += delta.y\n\n      interaction.offsetBy(delta)\n      interaction.move({ skipModifiers: this.modifierCount })\n\n      this.onNextFrame(() => this.smoothEndTick())\n    } else {\n      interaction.offsetBy({\n        x: this.targetOffset.x - this.currentOffset.x,\n        y: this.targetOffset.y - this.currentOffset.y,\n      })\n\n      this.end()\n    }\n  }\n\n  resume({ pointer, event, eventTarget }: SignalArgs['interactions:down']) {\n    const { interaction } = this\n\n    // undo inertia changes to interaction coords\n    interaction.offsetBy({\n      x: -this.currentOffset.x,\n      y: -this.currentOffset.y,\n    })\n\n    // update pointer at pointer down position\n    interaction.updatePointer(pointer, event, eventTarget, true)\n\n    // fire resume signals and event\n    interaction._doPhase({\n      interaction,\n      event,\n      phase: 'resume',\n    })\n    copyCoords(interaction.coords.prev, interaction.coords.cur)\n\n    this.stop()\n  }\n\n  end() {\n    this.interaction.move()\n    this.interaction.end()\n    this.stop()\n  }\n\n  stop() {\n    this.active = this.smoothEnd = false\n    this.interaction.simulation = null\n    raf.cancel(this.timeout)\n  }\n}\n\nfunction start({ interaction, event }: DoPhaseArg<ActionName, 'end'>) {\n  if (!interaction._interacting || interaction.simulation) {\n    return null\n  }\n\n  const started = interaction.inertia.start(event)\n\n  // prevent action end if inertia or smoothEnd\n  return started ? false : null\n}\n\n// Check if the down event hits the current inertia target\n// control should be return to the user\nfunction resume(arg: SignalArgs['interactions:down']) {\n  const { interaction, eventTarget } = arg\n  const state = interaction.inertia\n\n  if (!state.active) return\n\n  let element = eventTarget as Node\n\n  // climb up the DOM tree from the event target\n  while (is.element(element)) {\n    // if interaction element is the current inertia target element\n    if (element === interaction.element) {\n      state.resume(arg)\n      break\n    }\n\n    element = dom.parentNode(element)\n  }\n}\n\nfunction stop({ interaction }: { interaction: Interaction }) {\n  const state = interaction.inertia\n\n  if (state.active) {\n    state.stop()\n  }\n}\n\nfunction getOptions({ interactable, prepared }: Interaction) {\n  return interactable && interactable.options && prepared.name && interactable.options[prepared.name].inertia\n}\n\nconst inertia: Plugin = {\n  id: 'inertia',\n  before: ['modifiers', 'actions'],\n  install,\n  listeners: {\n    'interactions:new': ({ interaction }) => {\n      interaction.inertia = new InertiaState(interaction)\n    },\n\n    'interactions:before-action-end': start,\n    'interactions:down': resume,\n    'interactions:stop': stop,\n\n    'interactions:before-action-resume': (arg) => {\n      const { modification } = arg.interaction\n\n      modification.stop(arg)\n      modification.start(arg, arg.interaction.coords.cur.page)\n      modification.applyToInteraction(arg)\n    },\n\n    'interactions:before-action-inertiastart': (arg) => arg.interaction.modification.setAndApply(arg),\n    'interactions:action-resume': modifiers.addEventModifiers,\n    'interactions:action-inertiastart': modifiers.addEventModifiers,\n    'interactions:after-action-inertiastart': (arg) =>\n      arg.interaction.modification.restoreInteractionCoords(arg),\n    'interactions:after-action-resume': (arg) => arg.interaction.modification.restoreInteractionCoords(arg),\n  },\n}\n\n// http://stackoverflow.com/a/5634528/2280888\nfunction _getQBezierValue(t: number, p1: number, p2: number, p3: number) {\n  const iT = 1 - t\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3\n}\n\nfunction getQuadraticCurvePoint(\n  startX: number,\n  startY: number,\n  cpX: number,\n  cpY: number,\n  endX: number,\n  endY: number,\n  position: number,\n) {\n  return {\n    x: _getQBezierValue(position, startX, cpX, endX),\n    y: _getQBezierValue(position, startY, cpY, endY),\n  }\n}\n\n// http://gizma.com/easing/\nfunction easeOutQuad(t: number, b: number, c: number, d: number) {\n  t /= d\n  return -c * t * (t - 2) + b\n}\n\nexport default inertia\n"],"names":["install","scope","defaults","usePlugin","offset","modifiers","default","actions","phases","inertiastart","resume","perAction","inertia","enabled","resistance","minSpeed","endSpeed","allowResume","smoothEndDuration","InertiaState","active","interaction","isModified","smoothEnd","modifierCount","this","startCoords","t0","v0","lambda_v0","one_ve_v0","start","event","options","getOptions","pointerSpeed","coords","velocity","modification","hypot","y","Modification","_now","currentOffset","x","cur","page","preEnd","fillArg","phase","thrown","timeStamp","startInertia","setAll","modifierArg","result","changed","rect","offsetBy","targetOffset","_doPhase","simulation","lambda","client","inertiaDur","startVelocity","log","pageCoords","modifiedOffset","delta","inertiaTick","onNextFrame","smoothEndTick","tickFn","raf","request","t","progress","Math","exp","newOffset","getQuadraticCurvePoint","move","end","duration","easeOutQuad","skipModifiers","_ref","pointer","eventTarget","updatePointer","copyCoords","prev","stop","timeout","cancel","_ref2","_interacting","arg","element","is","state","dom","parentNode","_ref3","_ref4","prepared","interactable","name","id","before","listeners","_ref5","applyToInteraction","setAndApply","addEventModifiers","restoreInteractionCoords","iT","p2","cpX","_getQBezierValue","startX","startY","endX","cpY","endY","position","b","d"],"mappings":"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"}