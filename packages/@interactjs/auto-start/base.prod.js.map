{"version":3,"file":"base.prod.js","sources":["base.ts"],"sourcesContent":["import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type {\n  CursorChecker,\n  PointerType,\n  PointerEventType,\n  Element,\n  ActionName,\n  ActionProps,\n} from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './InteractableMethods'\nimport InteractableMethods from './InteractableMethods'\n/* eslint-enable import/no-duplicates */\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    /**\n     * Returns or sets the maximum number of concurrent interactions allowed.  By\n     * default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables and\n     * elements, you need to enable it in the draggable, resizable and gesturable\n     * `'max'` and `'maxPerElement'` options.\n     *\n     * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n     */\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit<SignalArgs['interactions:move'], 'interaction'> & {\n      interaction: Interaction<ActionName>\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps<ActionName>\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install(scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove(arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction<ActionName>).prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends ActionName>(\n  action: ActionProps<T>,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n    interactable.options[action.name].enabled &&\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches(\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction<ActionName>(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo(\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches(interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare(\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps<any>\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends ActionName>(\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions(newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor(element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends ActionName>(interaction: Interaction<T>, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n"],"names":["install","scope","interactStatic","interact","defaults","usePlugin","InteractableMethods","base","actionChecker","styleCursor","extend","perAction","manualStart","max","Infinity","maxPerElement","allowFrom","ignoreFrom","mouseButtons","maxInteractions","newValue","autoStart","withinInteractionLimit","cursorElement","prepareOnDown","_ref","interaction","pointer","event","eventTarget","interacting","prepare","getActionInfo","prepareOnMove","_ref2","pointerType","pointerIsDown","startOnMove","arg","pointerWasMoved","prepared","name","fire","interactable","actionName","options","element","stop","start","setInteractionCursor","clearCursorOnStop","_ref3","setCursor","validateAction","action","testIgnoreAllow","enabled","validateMatches","matches","matchElements","i","len","length","match","matchElement","matchAction","getAction","pushMatches","push","is","interactables","forEachMatch","actionInfo","domUtils","parentNode","_ref4","copyAction","rect","getRect","maxActions","autoStartMax","activeInteractions","interactableCount","elementCount","interactions","list","otherAction","number","this","cursor","prevCursorElement","style","ownerDocument","documentElement","cursorChecker","func","_interacting","actions","map","getCursor","id","before","listeners"],"mappings":"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"}