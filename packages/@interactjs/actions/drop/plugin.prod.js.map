{"version":3,"file":"plugin.prod.js","sources":["plugin.ts"],"sourcesContent":["import type { Interactable } from '@interactjs/core/Interactable'\nimport type { EventPhase, InteractEvent } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Element, PointerEventType, Rect, ListenersArg } from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport is from '@interactjs/utils/is'\nimport normalizeListeners from '@interactjs/utils/normalizeListeners'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport '../drag/plugin'\n\nimport type { DragEvent } from '../drag/plugin'\nimport drag from '../drag/plugin'\n/* eslint-enable import/no-duplicates */\n\nimport { DropEvent } from './DropEvent'\n\nexport type DropFunctionChecker = (\n  dragEvent: any, // related drag operation\n  event: any, // touch or mouse EventEmitter\n  dropped: boolean, // default checker result\n  dropzone: Interactable, // dropzone interactable\n  dropElement: Element, // drop zone element\n  draggable: Interactable, // draggable's Interactable\n  draggableElement: Element, // dragged element\n) => boolean\n\nexport interface DropzoneOptions extends PerActionDefaults {\n  accept?:\n    | string\n    | Element\n    | (({ dropzone, draggableElement }: { dropzone: Interactable; draggableElement: Element }) => boolean)\n  // How the overlap is checked on the drop zone\n  overlap?: 'pointer' | 'center' | number\n  checker?: DropFunctionChecker\n\n  ondropactivate?: ListenersArg\n  ondropdeactivate?: ListenersArg\n  ondragenter?: ListenersArg\n  ondragleave?: ListenersArg\n  ondropmove?: ListenersArg\n  ondrop?: ListenersArg\n}\n\nexport interface DropzoneMethod {\n  (this: Interactable, options: DropzoneOptions | boolean): Interactable\n  (): DropzoneOptions\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    /**\n     *\n     * ```js\n     * interact('.drop').dropzone({\n     *   accept: '.can-drop' || document.getElementById('single-drop'),\n     *   overlap: 'pointer' || 'center' || zeroToOne\n     * }\n     * ```\n     *\n     * Returns or sets whether draggables can be dropped onto this target to\n     * trigger drop events\n     *\n     * Dropzones can receive the following events:\n     *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n     *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n     *  - `dragmove` when a draggable that has entered the dropzone is moved\n     *  - `drop` when a draggable is dropped into this dropzone\n     *\n     * Use the `accept` option to allow only elements that match the given CSS\n     * selector or element. The value can be:\n     *\n     *  - **an Element** - only that element can be dropped into this dropzone.\n     *  - **a string**, - the element being dragged must match it as a CSS selector.\n     *  - **`null`** - accept options is cleared - it accepts any element.\n     *\n     * Use the `overlap` option to set how drops are checked for. The allowed\n     * values are:\n     *\n     *   - `'pointer'`, the pointer must be over the dropzone (default)\n     *   - `'center'`, the draggable element's center must be over the dropzone\n     *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n     *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n     *   over the dropzone\n     *\n     * Use the `checker` option to specify a function to check if a dragged element\n     * is over this Interactable.\n     *\n     * @param options - The new options to be set\n     */\n    dropzone(options: DropzoneOptions | boolean): Interactable\n    /** @returns The current setting */\n    dropzone(): DropzoneOptions\n\n    /**\n     * ```js\n     * interact(target)\n     * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n     *                       event,             // TouchEvent/PointerEvent/MouseEvent\n     *                       dropped,           // bool result of the default checker\n     *                       dropzone,          // dropzone Interactable\n     *                       dropElement,       // dropzone elemnt\n     *                       draggable,         // draggable Interactable\n     *                       draggableElement) {// draggable element\n     *\n     *   return dropped && event.target.hasAttribute('allow-drop')\n     * }\n     * ```\n     */\n    dropCheck(\n      dragEvent: InteractEvent,\n      event: PointerEventType,\n      draggable: Interactable,\n      draggableElement: Element,\n      dropElemen: Element,\n      rect: any,\n    ): boolean\n  }\n}\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    dropState?: DropState\n  }\n}\n\ndeclare module '@interactjs/core/InteractEvent' {\n  interface InteractEvent {\n    /** @internal */\n    prevDropzone?: Interactable\n    dropzone?: Interactable\n    dragEnter?: Element\n    dragLeave?: Element\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    drop: DropzoneOptions\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    dynamicDrop?: boolean\n  }\n\n  interface SignalArgs {\n    'actions/drop:start': DropSignalArg\n    'actions/drop:move': DropSignalArg\n    'actions/drop:end': DropSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/types' {\n  interface ActionMap {\n    drop?: typeof drop\n  }\n}\n\ndeclare module '@interactjs/core/InteractStatic' {\n  interface InteractStatic {\n    /**\n     * Returns or sets whether the dimensions of dropzone elements are calculated\n     * on every dragmove or only on dragstart for the default dropChecker\n     *\n     * @param {boolean} [newValue] True to check on each move. False to check only\n     * before start\n     * @return {boolean | interact} The current setting or interact\n     */\n    dynamicDrop: (newValue?: boolean) => boolean | this\n  }\n}\n\ninterface DropSignalArg {\n  interaction: Interaction<'drag'>\n  dragEvent: DragEvent\n}\n\nexport interface ActiveDrop {\n  dropzone: Interactable\n  element: Element\n  rect: Rect\n}\n\nexport interface DropState {\n  cur: {\n    // the dropzone a drag target might be dropped into\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  prev: {\n    // the dropzone that was recently dragged away from\n    dropzone: Interactable\n    // the element at the time of checking\n    element: Element\n  }\n  // wheather the potential drop was rejected from a listener\n  rejected: boolean\n  // the drop events related to the current drag event\n  events: FiredDropEvents\n  activeDrops: ActiveDrop[]\n}\n\nfunction install(scope: Scope) {\n  const { actions, interactStatic: interact, Interactable, defaults } = scope\n\n  scope.usePlugin(drag)\n\n  Interactable.prototype.dropzone = function (this: Interactable, options) {\n    return dropzoneMethod(this, options)\n  } as Interactable['dropzone']\n\n  Interactable.prototype.dropCheck = function (\n    this: Interactable,\n    dragEvent,\n    event,\n    draggable,\n    draggableElement,\n    dropElement,\n    rect,\n  ) {\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\n  }\n\n  interact.dynamicDrop = function (newValue?: boolean) {\n    if (is.bool(newValue)) {\n      // if (dragging && scope.dynamicDrop !== newValue && !newValue) {\n      //  calcRects(dropzones)\n      // }\n\n      scope.dynamicDrop = newValue\n\n      return interact\n    }\n    return scope.dynamicDrop!\n  }\n\n  extend(actions.phaselessTypes, {\n    dragenter: true,\n    dragleave: true,\n    dropactivate: true,\n    dropdeactivate: true,\n    dropmove: true,\n    drop: true,\n  })\n  actions.methodDict.drop = 'dropzone'\n\n  scope.dynamicDrop = false\n\n  defaults.actions.drop = drop.defaults\n}\n\nfunction collectDropzones({ interactables }: Scope, draggableElement: Element) {\n  const drops: ActiveDrop[] = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const dropzone of interactables.list) {\n    if (!dropzone.options.drop.enabled) {\n      continue\n    }\n\n    const accept = dropzone.options.drop.accept\n\n    // test the draggable draggableElement against the dropzone's accept setting\n    if (\n      (is.element(accept) && accept !== draggableElement) ||\n      (is.string(accept) && !domUtils.matchesSelector(draggableElement, accept)) ||\n      (is.func(accept) && !accept({ dropzone, draggableElement }))\n    ) {\n      continue\n    }\n\n    for (const dropzoneElement of dropzone.getAllElements()) {\n      if (dropzoneElement !== draggableElement) {\n        drops.push({\n          dropzone,\n          element: dropzoneElement,\n          rect: dropzone.getRect(dropzoneElement),\n        })\n      }\n    }\n  }\n\n  return drops\n}\n\nfunction fireActivationEvents(activeDrops: ActiveDrop[], event: DropEvent) {\n  // loop through all active dropzones and trigger event\n  for (const { dropzone, element } of activeDrops.slice()) {\n    event.dropzone = dropzone\n\n    // set current element as event target\n    event.target = element\n    dropzone.fire(event)\n    event.propagationStopped = event.immediatePropagationStopped = false\n  }\n}\n\n// return a new array of possible drops. getActiveDrops should always be\n// called when a drag has just started or a drag event happens while\n// dynamicDrop is true\nfunction getActiveDrops(scope: Scope, dragElement: Element) {\n  // get dropzones and their elements that could receive the draggable\n  const activeDrops = collectDropzones(scope, dragElement)\n\n  for (const activeDrop of activeDrops) {\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\n  }\n\n  return activeDrops\n}\n\nfunction getDrop(\n  { dropState, interactable: draggable, element: dragElement }: Interaction,\n  dragEvent,\n  pointerEvent,\n) {\n  const validDrops: Element[] = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {\n    const isValid = dropzone.dropCheck(\n      dragEvent,\n      pointerEvent,\n      draggable!,\n      dragElement!,\n      dropzoneElement,\n      rect,\n    )\n    validDrops.push(isValid ? dropzoneElement : null)\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = domUtils.indexOfDeepestElement(validDrops)\n\n  return dropState!.activeDrops[dropIndex] || null\n}\n\nfunction getDropEvents(interaction: Interaction, _pointerEvent, dragEvent: DragEvent) {\n  const dropState = interaction.dropState!\n  const dropEvents: Record<string, DropEvent | null> = {\n    enter: null,\n    leave: null,\n    activate: null,\n    deactivate: null,\n    move: null,\n    drop: null,\n  }\n\n  if (dragEvent.type === 'dragstart') {\n    dropEvents.activate = new DropEvent(dropState, dragEvent, 'dropactivate')\n\n    dropEvents.activate.target = null as never\n    dropEvents.activate.dropzone = null as never\n  }\n  if (dragEvent.type === 'dragend') {\n    dropEvents.deactivate = new DropEvent(dropState, dragEvent, 'dropdeactivate')\n\n    dropEvents.deactivate.target = null as never\n    dropEvents.deactivate.dropzone = null as never\n  }\n\n  if (dropState.rejected) {\n    return dropEvents\n  }\n\n  if (dropState.cur.element !== dropState.prev.element) {\n    // if there was a previous dropzone, create a dragleave event\n    if (dropState.prev.dropzone) {\n      dropEvents.leave = new DropEvent(dropState, dragEvent, 'dragleave')\n\n      dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone\n    }\n    // if dropzone is not null, create a dragenter event\n    if (dropState.cur.dropzone) {\n      dropEvents.enter = new DropEvent(dropState, dragEvent, 'dragenter')\n\n      dragEvent.dragEnter = dropState.cur.element\n      dragEvent.dropzone = dropState.cur.dropzone\n    }\n  }\n\n  if (dragEvent.type === 'dragend' && dropState.cur.dropzone) {\n    dropEvents.drop = new DropEvent(dropState, dragEvent, 'drop')\n\n    dragEvent.dropzone = dropState.cur.dropzone\n    dragEvent.relatedTarget = dropState.cur.element\n  }\n  if (dragEvent.type === 'dragmove' && dropState.cur.dropzone) {\n    dropEvents.move = new DropEvent(dropState, dragEvent, 'dropmove')\n\n    dragEvent.dropzone = dropState.cur.dropzone\n  }\n\n  return dropEvents\n}\n\ntype FiredDropEvents = Partial<\n  Record<'leave' | 'enter' | 'move' | 'drop' | 'activate' | 'deactivate', DropEvent>\n>\n\nfunction fireDropEvents(interaction: Interaction, events: FiredDropEvents) {\n  const dropState = interaction.dropState!\n  const { activeDrops, cur, prev } = dropState\n\n  if (events.leave) {\n    prev.dropzone.fire(events.leave)\n  }\n  if (events.enter) {\n    cur.dropzone.fire(events.enter)\n  }\n  if (events.move) {\n    cur.dropzone.fire(events.move)\n  }\n  if (events.drop) {\n    cur.dropzone.fire(events.drop)\n  }\n\n  if (events.deactivate) {\n    fireActivationEvents(activeDrops, events.deactivate)\n  }\n\n  dropState.prev.dropzone = cur.dropzone\n  dropState.prev.element = cur.element\n}\n\nfunction onEventCreated({ interaction, iEvent, event }: DoPhaseArg<'drag', EventPhase>, scope: Scope) {\n  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {\n    return\n  }\n\n  const dropState = interaction.dropState!\n\n  if (scope.dynamicDrop) {\n    dropState.activeDrops = getActiveDrops(scope, interaction.element!)\n  }\n\n  const dragEvent = iEvent\n  const dropResult = getDrop(interaction, dragEvent, event)\n\n  // update rejected status\n  dropState.rejected =\n    dropState.rejected &&\n    !!dropResult &&\n    dropResult.dropzone === dropState.cur.dropzone &&\n    dropResult.element === dropState.cur.element\n\n  dropState.cur.dropzone = dropResult && dropResult.dropzone\n  dropState.cur.element = dropResult && dropResult.element\n\n  dropState.events = getDropEvents(interaction, event, dragEvent)\n}\n\nfunction dropzoneMethod(interactable: Interactable): DropzoneOptions\nfunction dropzoneMethod(interactable: Interactable, options: DropzoneOptions | boolean): Interactable\nfunction dropzoneMethod(interactable: Interactable, options?: DropzoneOptions | boolean) {\n  if (is.object(options)) {\n    interactable.options.drop.enabled = options.enabled !== false\n\n    if (options.listeners) {\n      const normalized = normalizeListeners(options.listeners)\n      // rename 'drop' to '' as it will be prefixed with 'drop'\n      const corrected = Object.keys(normalized).reduce((acc, type) => {\n        const correctedType = /^(enter|leave)/.test(type)\n          ? `drag${type}`\n          : /^(activate|deactivate|move)/.test(type)\n            ? `drop${type}`\n            : type\n\n        acc[correctedType] = normalized[type]\n\n        return acc\n      }, {})\n\n      const prevListeners = interactable.options.drop.listeners\n      prevListeners && interactable.off(prevListeners)\n\n      interactable.on(corrected)\n      interactable.options.drop.listeners = corrected\n    }\n\n    if (is.func(options.ondrop)) {\n      interactable.on('drop', options.ondrop)\n    }\n    if (is.func(options.ondropactivate)) {\n      interactable.on('dropactivate', options.ondropactivate)\n    }\n    if (is.func(options.ondropdeactivate)) {\n      interactable.on('dropdeactivate', options.ondropdeactivate)\n    }\n    if (is.func(options.ondragenter)) {\n      interactable.on('dragenter', options.ondragenter)\n    }\n    if (is.func(options.ondragleave)) {\n      interactable.on('dragleave', options.ondragleave)\n    }\n    if (is.func(options.ondropmove)) {\n      interactable.on('dropmove', options.ondropmove)\n    }\n\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\n      interactable.options.drop.overlap = options.overlap\n    } else if (is.number(options.overlap)) {\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\n    }\n    if ('accept' in options) {\n      interactable.options.drop.accept = options.accept\n    }\n    if ('checker' in options) {\n      interactable.options.drop.checker = options.checker\n    }\n\n    return interactable\n  }\n\n  if (is.bool(options)) {\n    interactable.options.drop.enabled = options\n\n    return interactable\n  }\n\n  return interactable.options.drop\n}\n\nfunction dropCheckMethod(\n  interactable: Interactable,\n  dragEvent: InteractEvent,\n  event: PointerEventType,\n  draggable: Interactable,\n  draggableElement: Element,\n  dropElement: Element,\n  rect: any,\n) {\n  let dropped = false\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || interactable.getRect(dropElement))) {\n    return interactable.options.drop.checker\n      ? interactable.options.drop.checker(\n          dragEvent,\n          event,\n          dropped,\n          interactable,\n          dropElement,\n          draggable,\n          draggableElement,\n        )\n      : false\n  }\n\n  const dropOverlap = interactable.options.drop.overlap\n\n  if (dropOverlap === 'pointer') {\n    const origin = getOriginXY(draggable, draggableElement, 'drag')\n    const page = pointerUtils.getPageXY(dragEvent)\n\n    page.x += origin.x\n    page.y += origin.y\n\n    const horizontal = page.x > rect.left && page.x < rect.right\n    const vertical = page.y > rect.top && page.y < rect.bottom\n\n    dropped = horizontal && vertical\n  }\n\n  const dragRect = draggable.getRect(draggableElement)\n\n  if (dragRect && dropOverlap === 'center') {\n    const cx = dragRect.left + dragRect.width / 2\n    const cy = dragRect.top + dragRect.height / 2\n\n    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom\n  }\n\n  if (dragRect && is.number(dropOverlap)) {\n    const overlapArea =\n      Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\n      Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top))\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\n\n    dropped = overlapRatio >= dropOverlap\n  }\n\n  if (interactable.options.drop.checker) {\n    dropped = interactable.options.drop.checker(\n      dragEvent,\n      event,\n      dropped,\n      interactable,\n      dropElement,\n      draggable,\n      draggableElement,\n    )\n  }\n\n  return dropped\n}\n\nconst drop: Plugin = {\n  id: 'actions/drop',\n  install,\n  listeners: {\n    'interactions:before-action-start': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      interaction.dropState = {\n        cur: {\n          dropzone: null,\n          element: null,\n        },\n        prev: {\n          dropzone: null,\n          element: null,\n        },\n        rejected: null,\n        events: null,\n        activeDrops: [],\n      }\n    },\n\n    'interactions:after-action-start': (\n      { interaction, event, iEvent: dragEvent }: DoPhaseArg<'drag', EventPhase>,\n      scope,\n    ) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const dropState = interaction.dropState!\n\n      // reset active dropzones\n      dropState.activeDrops = []\n      dropState.events = {}\n      dropState.activeDrops = getActiveDrops(scope, interaction.element!)\n      dropState.events = getDropEvents(interaction, event, dragEvent)\n\n      if (dropState.events.activate) {\n        fireActivationEvents(dropState.activeDrops, dropState.events.activate)\n        scope.fire('actions/drop:start', { interaction, dragEvent })\n      }\n    },\n\n    'interactions:action-move': onEventCreated,\n\n    'interactions:after-action-move': (\n      { interaction, iEvent: dragEvent }: DoPhaseArg<'drag', EventPhase>,\n      scope,\n    ) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const dropState = interaction.dropState!\n      fireDropEvents(interaction, dropState.events)\n\n      scope.fire('actions/drop:move', { interaction, dragEvent })\n      dropState.events = {}\n    },\n\n    'interactions:action-end': (arg: DoPhaseArg<'drag', EventPhase>, scope) => {\n      if (arg.interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { interaction, iEvent: dragEvent } = arg\n\n      onEventCreated(arg, scope)\n      fireDropEvents(interaction, interaction.dropState!.events)\n      scope.fire('actions/drop:end', { interaction, dragEvent })\n    },\n\n    'interactions:stop': ({ interaction }) => {\n      if (interaction.prepared.name !== 'drag') {\n        return\n      }\n\n      const { dropState } = interaction\n\n      if (dropState) {\n        dropState.activeDrops = null as never\n        dropState.events = null as never\n        dropState.cur.dropzone = null as never\n        dropState.cur.element = null as never\n        dropState.prev.dropzone = null as never\n        dropState.prev.element = null as never\n        dropState.rejected = false\n      }\n    },\n  },\n  getActiveDrops,\n  getDrop,\n  getDropEvents,\n  fireDropEvents,\n\n  filterEventType: (type: string) => type.search('drag') === 0 || type.search('drop') === 0,\n\n  defaults: {\n    enabled: false,\n    accept: null as never,\n    overlap: 'pointer',\n  } as DropzoneOptions,\n}\n\nexport default drop\n"],"names":["install","actions","interact","Interactable","interactStatic","defaults","scope","drag","usePlugin","dropzone","options","prototype","dropCheck","dragEvent","event","draggable","draggableElement","dropElement","rect","this","dynamicDrop","newValue","phaselessTypes","dragenter","dragleave","dropactivate","dropdeactivate","dropmove","methodDict","drop","collectDropzones","_ref","interactables","list","enabled","accept","is","element","string","domUtils","matchesSelector","func","dropzoneElement","getAllElements","drops","getRect","fireActivationEvents","activeDrops","slice","target","fire","immediatePropagationStopped","getActiveDrops","dragElement","activeDrop","getDrop","_ref2","pointerEvent","dropState","interactable","validDrops","push","dropIndex","indexOfDeepestElement","getDropEvents","interaction","_pointerEvent","enter","leave","activate","deactivate","move","type","dropEvents","DropEvent","rejected","cur","prev","dragLeave","dragEnter","fireDropEvents","events","onEventCreated","_ref3","iEvent","dropResult","dropzoneMethod","listeners","normalizeListeners","corrected","Object","keys","normalized","reduce","acc","test","prevListeners","off","on","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","overlap","number","Math","max","min","checker","bool","dropCheckMethod","dropped","dropOverlap","getOriginXY","origin","pointerUtils","getPageXY","page","x","horizontal","left","right","top","bottom","dragRect","cx","height","cy","width","overlapArea","id","_ref4","prepared","name","_ref5","_ref6","arg","_ref7","search","filterEventType"],"mappings":"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"}