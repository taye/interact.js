{"version":3,"file":"interactionFinder.prod.js","sources":["interactionFinder.ts"],"sourcesContent":["import * as dom from '@interactjs/utils/domUtils'\n\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/core/types'\n\nexport interface SearchDetails {\n  pointer: PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: EventTarget\n  curEventTarget: EventTarget\n  scope: Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search(details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (\n        interaction.simulation &&\n        interaction.simulation.allowResume &&\n        interaction.pointerType === pointerType\n      ) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {\n          continue\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !(target.options.gesture && target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && pointerType === interaction.pointerType) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId(interaction: Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) => id === pointerId)\n}\n\nexport default finder\n"],"names":["methodOrder","search","details","finder","method","interaction","simulationResume","_ref","pointerType","eventType","eventTarget","scope","test","interactions","list","element","simulation","allowResume","domUtils","parentNode","mouseOrPen","_ref2","firstNonActive","pointerId","hasPointerId","interacting","hasPointer","_ref3","idle","_ref4","pointers","length","interactable","target","options","gesture","enabled","some","id"],"mappings":";;iEAgBAA,YAAe,CAAA,mBAAA,aAAA,aAAA,QACbA,MAAAA,CAAAA,GAEAC,IAAOC,MAAAA,KAAwBC,OAAAH,YAAA,OAClBI,EAAgBD,aACzB,GAAAE,EAEA,QAEA,CACF,OAAA,IAEA,EAGF,gBAAAC,CAAAC,GACAD,IAAAA,YAAiBE,EAAAC,UAAED,EAAWE,YAAED,EAASE,MAAED,GAAaC,EAAsB,kBAAAC,KAAAH,GAC5E,OAAkB,KAElB,IAAA,MAAAJ,KAAAM,EAAAE,aAAAC,KAAA,CAEA,MAAsBJ,EACpB,GAAIK,EAAUL,YAAmBL,EAAAW,WAAAC,aAAAZ,EAAAG,cAAAA,OAGpBO,GAAW,CAKpB,GAAAA,IAAAV,EAAAU,eACWV,EAEXU,EAAAG,SAAAC,WAAAJ,EACAA,CAEJ,CACF,OAAA,IAEA,EAGF,UAAAK,CAAAC,GACAD,IAGEE,GAHFF,UAAWG,EAAAf,YAAEe,EAASd,UAAED,EAAWG,MAAEF,GAAWE,EAAsB,GAAA,UAAAU,GAAA,QAAAb,EACpE,YAIA,eAAkBG,EAAAE,aAAAC,KAElB,KAAsBN,cAAUK,EAAaC,CAEzC,GAAAT,EAAAW,aAAAQ,aAAAnB,EAAAkB,GACIlB,SAIJ,GAAAA,EAAAoB,cACIpB,OAAAA,EAGJiB,IACKA,EAAKA,EAEV,CAKJ,GAAAA,EACA,SAMA,IAAA,MAAAjB,KAAAM,EAAAE,aAAAC,KACA,OAAsBN,cAAUK,GAAmB,QAAAD,KAAAH,IAAAJ,EAAAW,mBAClCX,EAGjB,OAAA,IAEA,EAGF,UAAAqB,CAAAC,GACAD,IAAAA,UAAWH,EAAAZ,MAAEY,GAAWZ,EAAsB,UAAAN,KAAAM,EAAAE,aAAAC,KAC5C,gBAAsBT,EAAUQ,UACdR,EAGlB,OAAA,IAEA,EAGF,IAAAuB,CAAAC,GACAD,IAAIC,YAACrB,EAAAG,MAAEH,GAAaG,EAAsB,UAAAN,KAAAM,EAAAE,aAAAC,KAAA,CAEtC,GAAA,IAAAT,EAAAyB,SAAAC,OAAA,CACA,QAAgBD,EAAeE,aAG7B,GAAAC,KAAAA,EAAAC,QAAAC,UAAAF,EAAAC,QAAAC,QAAAC,iBAGA,MAEF,GAAA/B,EAAAyB,SAAAC,QAAA,EACK,SAEL,IAAA1B,EAAAoB,eAAAjB,IAAAH,EAAAG,YAEI,OAAYH,CAEhB,CACF,OAAA,IAEA,GAEJ,SAACmB,aAAAnB,EAAAkB,GAED,OAASC,EAAYA,SAAyBa,MAAEd,IAC9C,IAAAe,GAAkCA,GAAEA,EAAI,WAAAf,CAAA,WAC1CpB"}