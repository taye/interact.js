{"version":3,"file":"interactionFinder.js","sources":["interactionFinder.ts"],"sourcesContent":["import * as dom from '@interactjs/utils/domUtils'\n\nimport type Interaction from '@interactjs/core/Interaction'\nimport type { Scope } from '@interactjs/core/scope'\nimport type { PointerType } from '@interactjs/core/types'\n\nexport interface SearchDetails {\n  pointer: PointerType\n  pointerId: number\n  pointerType: string\n  eventType: string\n  eventTarget: EventTarget\n  curEventTarget: EventTarget\n  scope: Scope\n}\n\nconst finder = {\n  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'] as const,\n\n  search(details: SearchDetails) {\n    for (const method of finder.methodOrder) {\n      const interaction = finder[method](details)\n\n      if (interaction) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // try to resume simulation with a new pointer\n  simulationResume({ pointerType, eventType, eventTarget, scope }: SearchDetails) {\n    if (!/down|start/i.test(eventType)) {\n      return null\n    }\n\n    for (const interaction of scope.interactions.list) {\n      let element = eventTarget as Node\n\n      if (\n        interaction.simulation &&\n        interaction.simulation.allowResume &&\n        interaction.pointerType === pointerType\n      ) {\n        while (element) {\n          // if the element is the interaction element\n          if (element === interaction.element) {\n            return interaction\n          }\n          element = dom.parentNode(element)\n        }\n      }\n    }\n\n    return null\n  },\n\n  // if it's a mouse or pen interaction\n  mouseOrPen({ pointerId, pointerType, eventType, scope }: SearchDetails) {\n    if (pointerType !== 'mouse' && pointerType !== 'pen') {\n      return null\n    }\n\n    let firstNonActive\n\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType) {\n        // if it's a down event, skip interactions with running simulations\n        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {\n          continue\n        }\n\n        // if the interaction is active, return it immediately\n        if (interaction.interacting()) {\n          return interaction\n        }\n        // otherwise save it and look for another active interaction\n        else if (!firstNonActive) {\n          firstNonActive = interaction\n        }\n      }\n    }\n\n    // if no active mouse interaction was found use the first inactive mouse\n    // interaction\n    if (firstNonActive) {\n      return firstNonActive\n    }\n\n    // find any mouse or pen interaction.\n    // ignore the interaction if the eventType is a *down, and a simulation\n    // is active\n    for (const interaction of scope.interactions.list) {\n      if (interaction.pointerType === pointerType && !(/down/i.test(eventType) && interaction.simulation)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get interaction that has this pointer\n  hasPointer({ pointerId, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      if (hasPointerId(interaction, pointerId)) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n\n  // get first idle interaction with a matching pointerType\n  idle({ pointerType, scope }: SearchDetails) {\n    for (const interaction of scope.interactions.list) {\n      // if there's already a pointer held down\n      if (interaction.pointers.length === 1) {\n        const target = interaction.interactable\n        // don't add this pointer if there is a target interactable and it\n        // isn't gesturable\n        if (target && !(target.options.gesture && target.options.gesture.enabled)) {\n          continue\n        }\n      }\n      // maximum of 2 pointers per interaction\n      else if (interaction.pointers.length >= 2) {\n        continue\n      }\n\n      if (!interaction.interacting() && pointerType === interaction.pointerType) {\n        return interaction\n      }\n    }\n\n    return null\n  },\n}\n\nfunction hasPointerId(interaction: Interaction, pointerId: number) {\n  return interaction.pointers.some(({ id }) => id === pointerId)\n}\n\nexport default finder\n"],"names":["finder","methodOrder","search","details","method","interaction","simulationResume","_ref","pointerType","eventType","eventTarget","scope","test","interactions","list","element","simulation","allowResume","dom","parentNode","mouseOrPen","_ref2","pointerId","firstNonActive","hasPointerId","interacting","hasPointer","_ref3","idle","_ref4","pointers","length","target","interactable","options","gesture","enabled","some","_ref5","id"],"mappings":"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"}