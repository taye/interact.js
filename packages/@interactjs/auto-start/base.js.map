{"version":3,"file":"base.js","sources":["base.ts"],"sourcesContent":["import type { Interactable } from '@interactjs/core/Interactable'\nimport type { Interaction } from '@interactjs/core/Interaction'\nimport type { Scope, SignalArgs, Plugin } from '@interactjs/core/scope'\nimport type {\n  CursorChecker,\n  PointerType,\n  PointerEventType,\n  Element,\n  ActionName,\n  ActionProps,\n} from '@interactjs/core/types'\nimport * as domUtils from '@interactjs/utils/domUtils'\nimport extend from '@interactjs/utils/extend'\nimport is from '@interactjs/utils/is'\nimport { copyAction } from '@interactjs/utils/misc'\n\n/* eslint-disable import/no-duplicates -- for typescript module augmentations */\nimport './InteractableMethods'\nimport InteractableMethods from './InteractableMethods'\n/* eslint-enable import/no-duplicates */\n\ndeclare module '@interactjs/core/InteractStatic' {\n  export interface InteractStatic {\n    /**\n     * Returns or sets the maximum number of concurrent interactions allowed.  By\n     * default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables and\n     * elements, you need to enable it in the draggable, resizable and gesturable\n     * `'max'` and `'maxPerElement'` options.\n     *\n     * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n     */\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n  }\n\n  interface SignalArgs {\n    'autoStart:before-start': Omit<SignalArgs['interactions:move'], 'interaction'> & {\n      interaction: Interaction<ActionName>\n    }\n    'autoStart:prepared': { interaction: Interaction }\n    'auto-start:check': CheckSignalArg\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface BaseDefaults {\n    actionChecker?: any\n    cursorChecker?: any\n    styleCursor?: any\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Element\n    ignoreFrom?: string | Element\n    cursorChecker?: CursorChecker\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    // TODO: docst\n    mouseButtons?: 0 | 1 | 2 | 4 | 8 | 16\n  }\n}\n\ninterface CheckSignalArg {\n  interactable: Interactable\n  interaction: Interaction\n  element: Element\n  action: ActionProps<ActionName>\n  buttons: number\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Element\n}\n\nfunction install(scope: Scope) {\n  const { interactStatic: interact, defaults } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom: null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  interact.maxInteractions = (newValue: number) => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:down'],\n  scope: Scope,\n) {\n  if (interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove(\n  { interaction, pointer, event, eventTarget }: SignalArgs['interactions:move'],\n  scope: Scope,\n) {\n  if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) return\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove(arg: SignalArgs['interactions:move'], scope: Scope) {\n  const { interaction } = arg\n\n  if (\n    !interaction.pointerIsDown ||\n    interaction.interacting() ||\n    !interaction.pointerWasMoved ||\n    !interaction.prepared.name\n  ) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n  const actionName = (interaction as Interaction<ActionName>).prepared.name\n\n  if (actionName && interactable) {\n    // check manualStart and interaction limit\n    if (\n      interactable.options[actionName].manualStart ||\n      !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)\n    ) {\n      interaction.stop()\n    } else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop({ interaction }: { interaction: Interaction }, scope: Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction<T extends ActionName>(\n  action: ActionProps<T>,\n  interactable: Interactable,\n  element: Element,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  if (\n    interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n    interactable.options[action.name].enabled &&\n    withinInteractionLimit(interactable, element, action, scope)\n  ) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches(\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  matches: Interactable[],\n  matchElements: Element[],\n  eventTarget: Node,\n  scope: Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) {\n      continue\n    }\n\n    const action = validateAction<ActionName>(matchAction, match, matchElement, eventTarget, scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo(\n  interaction: Interaction,\n  pointer: PointerType,\n  event: PointerEventType,\n  eventTarget: Node,\n  scope: Scope,\n) {\n  let matches: Interactable[] = []\n  let matchElements: Element[] = []\n\n  let element = eventTarget as Element\n\n  function pushMatches(interactable: Interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(\n      interaction,\n      pointer,\n      event,\n      matches,\n      matchElements,\n      eventTarget,\n      scope,\n    )\n\n    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = domUtils.parentNode(element) as Element\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare(\n  interaction: Interaction,\n  {\n    action,\n    interactable,\n    element,\n  }: {\n    action: ActionProps<any>\n    interactable: Interactable\n    element: Element\n  },\n  scope: Scope,\n) {\n  action = action || { name: null }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name ? interactable.getRect(element) : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit<T extends ActionName>(\n  interactable: Interactable,\n  element: Element,\n  action: ActionProps<T>,\n  scope: Scope,\n) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) {\n    return false\n  }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) {\n      continue\n    }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) {\n      continue\n    }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions(newValue: any, scope: Scope) {\n  if (is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor(element: Element, cursor: string, scope: Scope) {\n  const { cursorElement: prevCursorElement } = scope.autoStart\n\n  if (prevCursorElement && prevCursorElement !== element) {\n    prevCursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor<T extends ActionName>(interaction: Interaction<T>, scope: Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    // clear previous target element cursor\n    if (scope.autoStart.cursorElement) {\n      setCursor(scope.autoStart.cursorElement, '', scope)\n    }\n\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    } else {\n      cursor = scope.actions.map[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nconst autoStart: Plugin = {\n  id: 'auto-start/base',\n  before: ['actions'],\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n}\n\nexport default autoStart\n"],"names":["install","scope","interactStatic","interact","defaults","usePlugin","InteractableMethods","base","actionChecker","styleCursor","extend","perAction","manualStart","max","Infinity","maxPerElement","allowFrom","ignoreFrom","mouseButtons","maxInteractions","newValue","autoStart","withinInteractionLimit","cursorElement","prepareOnDown","_ref","interaction","pointer","event","eventTarget","interacting","actionInfo","getActionInfo","prepare","prepareOnMove","_ref2","pointerType","pointerIsDown","startOnMove","arg","pointerWasMoved","prepared","name","fire","interactable","actionName","options","element","stop","start","setInteractionCursor","clearCursorOnStop","_ref3","setCursor","validateAction","action","testIgnoreAllow","enabled","validateMatches","matches","matchElements","i","len","length","match","matchElement","matchAction","getAction","pushMatches","push","is","interactables","forEachMatch","domUtils","parentNode","_ref4","copyAction","rect","getRect","maxActions","autoStartMax","activeInteractions","interactableCount","elementCount","interactions","list","otherAction","number","cursor","prevCursorElement","style","ownerDocument","documentElement","cursorChecker","func","_interacting","actions","map","getCursor","id","before","listeners","interactions:move"],"mappings":"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"}