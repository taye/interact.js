{"version":3,"file":"pointer.prod.js","sources":["pointer.ts"],"sourcesContent":["import type { Interaction, InteractionProxy } from '@interactjs/core/Interaction'\nimport type { ActionName, Point, RectResolvable, Element } from '@interactjs/core/types'\nimport extend from '@interactjs/utils/extend'\nimport getOriginXY from '@interactjs/utils/getOriginXY'\nimport hypot from '@interactjs/utils/hypot'\nimport is from '@interactjs/utils/is'\nimport { resolveRectLike, rectToXY } from '@interactjs/utils/rect'\n\nimport { makeModifier } from '../base'\nimport type { ModifierArg, ModifierState } from '../types'\n\nexport interface Offset {\n  x: number\n  y: number\n  index: number\n  relativePoint?: Point | null\n}\n\nexport interface SnapPosition {\n  x?: number\n  y?: number\n  range?: number\n  offset?: Offset\n  [index: string]: any\n}\n\nexport type SnapFunction = (\n  x: number,\n  y: number,\n  interaction: InteractionProxy<ActionName>,\n  offset: Offset,\n  index: number,\n) => SnapPosition\nexport type SnapTarget = SnapPosition | SnapFunction\nexport interface SnapOptions {\n  targets?: SnapTarget[]\n  // target range\n  range?: number\n  // self points for snapping. [0,0] = top left, [1,1] = bottom right\n  relativePoints?: Point[]\n  // startCoords = offset snapping from drag start page position\n  offset?: Point | RectResolvable<[Interaction]> | 'startCoords'\n  offsetWithOrigin?: boolean\n  origin?: RectResolvable<[Element]> | Point\n  endOnly?: boolean\n  enabled?: boolean\n}\n\nexport type SnapState = ModifierState<\n  SnapOptions,\n  {\n    offsets?: Offset[]\n    closest?: any\n    targetFields?: string[][]\n  }\n>\n\nfunction start(arg: ModifierArg<SnapState>) {\n  const { interaction, interactable, element, rect, state, startOffset } = arg\n  const { options } = state\n  const origin = options.offsetWithOrigin ? getOrigin(arg) : { x: 0, y: 0 }\n\n  let snapOffset: Point\n\n  if (options.offset === 'startCoords') {\n    snapOffset = {\n      x: interaction.coords.start.page.x,\n      y: interaction.coords.start.page.y,\n    }\n  } else {\n    const offsetRect = resolveRectLike(options.offset as any, interactable, element, [interaction])\n\n    snapOffset = rectToXY(offsetRect) || { x: 0, y: 0 }\n    snapOffset.x += origin.x\n    snapOffset.y += origin.y\n  }\n\n  const { relativePoints } = options\n\n  state.offsets =\n    rect && relativePoints && relativePoints.length\n      ? relativePoints.map((relativePoint, index) => ({\n          index,\n          relativePoint,\n          x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,\n          y: startOffset.top - rect.height * relativePoint.y + snapOffset.y,\n        }))\n      : [\n          {\n            index: 0,\n            relativePoint: null,\n            x: snapOffset.x,\n            y: snapOffset.y,\n          },\n        ]\n}\n\nfunction set(arg: ModifierArg<SnapState>) {\n  const { interaction, coords, state } = arg\n  const { options, offsets } = state\n\n  const origin = getOriginXY(interaction.interactable!, interaction.element!, interaction.prepared.name)\n  const page = extend({}, coords)\n  const targets: SnapPosition[] = []\n\n  if (!options.offsetWithOrigin) {\n    page.x -= origin.x\n    page.y -= origin.y\n  }\n\n  for (const offset of offsets!) {\n    const relativeX = page.x - offset.x\n    const relativeY = page.y - offset.y\n\n    for (let index = 0, len = options.targets!.length; index < len; index++) {\n      const snapTarget = options.targets![index]\n      let target: SnapPosition\n\n      if (is.func(snapTarget)) {\n        target = snapTarget(relativeX, relativeY, interaction._proxy, offset, index)\n      } else {\n        target = snapTarget\n      }\n\n      if (!target) {\n        continue\n      }\n\n      targets.push({\n        x: (is.number(target.x) ? target.x : relativeX) + offset.x,\n        y: (is.number(target.y) ? target.y : relativeY) + offset.y,\n\n        range: is.number(target.range) ? target.range : options.range,\n        source: snapTarget,\n        index,\n        offset,\n      })\n    }\n  }\n\n  const closest = {\n    target: null,\n    inRange: false,\n    distance: 0,\n    range: 0,\n    delta: { x: 0, y: 0 },\n  }\n\n  for (const target of targets) {\n    const range = target.range\n    const dx = target.x - page.x\n    const dy = target.y - page.y\n    const distance = hypot(dx, dy)\n    let inRange = distance <= range\n\n    // Infinite targets count as being out of range\n    // compared to non infinite ones that are in range\n    if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n      inRange = false\n    }\n\n    if (\n      !closest.target ||\n      (inRange\n        ? // is the closest target in range?\n          closest.inRange && range !== Infinity\n          ? // the pointer is relatively deeper in this target\n            distance / range < closest.distance / closest.range\n          : // this target has Infinite range and the closest doesn't\n            (range === Infinity && closest.range !== Infinity) ||\n            // OR this target is closer that the previous closest\n            distance < closest.distance\n        : // The other is not in range and the pointer is closer to this target\n          !closest.inRange && distance < closest.distance)\n    ) {\n      closest.target = target\n      closest.distance = distance\n      closest.range = range\n      closest.inRange = inRange\n      closest.delta.x = dx\n      closest.delta.y = dy\n    }\n  }\n\n  if (closest.inRange) {\n    coords.x = closest.target.x\n    coords.y = closest.target.y\n  }\n\n  state.closest = closest\n  return closest\n}\n\nfunction getOrigin(arg: Partial<ModifierArg<SnapState>>) {\n  const { element } = arg.interaction\n  const optionsOrigin = rectToXY(resolveRectLike(arg.state.options.origin as any, null, null, [element]))\n  const origin = optionsOrigin || getOriginXY(arg.interactable, element, arg.interaction.prepared.name)\n\n  return origin\n}\n\nconst defaults: SnapOptions = {\n  range: Infinity,\n  targets: null,\n  offset: null,\n  offsetWithOrigin: true,\n  origin: null,\n  relativePoints: null,\n  endOnly: false,\n  enabled: false,\n}\nconst snap = {\n  start,\n  set,\n  defaults,\n}\n\nexport default makeModifier(snap, 'snap')\nexport { snap }\n"],"names":["start","interaction","interactable","element","rect","state","startOffset","options","offsetWithOrigin","getOrigin","arg","x","snapOffset","coords","page","offsetRect","resolveRectLike","offset","rectToXY","origin","relativePoints","length","map","relativePoint","index","left","width","height","set","offsets","getOriginXY","prepared","name","extend","targets","relativeX","len","y","target","snapTarget","relativeY","_proxy","push","is","number","range","source","closest","inRange","distance","dx","dy","hypot","Infinity","delta","defaults","endOnly","snap","snap$1","makeModifier"],"mappings":";;yXAyDSA,MAAAA,YACDC,EAAAC,aAAED,EAAWE,QAAED,EAAYE,KAAED,EAAOE,MAAED,EAAIE,YAAED,GAAOC,WACnDC,GAAEA,IAAiBA,EAAAC,iBAAAC,UAAAC,GAAA,CACzBC,EAAA,EAA6DA,EAAG,OAASC,EAEzE,GAAqB,gBAAjBA,WAEc,KACHC,OAAAb,MAAAc,KAAAH,EACXA,EAAGV,EAAYY,OAAOb,MAAMc,KAAKH,OAElC,CACI,MAAAI,EAAAC,gBAAAT,EAAAU,OAAAf,EAAAC,EAAA,CAAAF,IACLW,EAAgBM,SAAkBH,SAEKJ,EAAG,KAASA,GAAAQ,EAAAR,EACnDC,EAAWD,GAAKQ,EAAOR,CACvBC,CACF,MAAAQ,eAEMA,GAAEA,EAAgBf,UAAUD,GAAAgB,GAAAA,EAAAC,OAAAD,EAAAE,KAAA,CAAAC,EAAAC,KAAA,CAElCnB,QAGQmB,gBACAD,EAAajB,EAAAmB,KAAArB,EAAAsB,MAAAH,EAAAZ,EAAAC,EAAAD,EACbA,EAAGL,EAAYmB,MAAWE,OAASJ,EAAcZ,EAAIC,EAAWD,MAC7DL,CAAAA,CACHkB,MAEA,EACEA,cAAQ,KACRD,EAAAA,IACAZ,EAAGC,EAAWD,GAEhB,CAEV,SAAAiB,IAAAlB,GAESkB,MAAAA,YACD3B,EAAAY,OAAEZ,EAAWI,MAAEQ,GAAQR,WACvBE,EAAAsB,QAAEtB,GAASsB,IAAiBC,YAAA7B,EAAAC,aAAAD,EAAAE,QAAAF,EAAA8B,SAAAC,MAE5Bb,EAAMc,aACNnB,EAAOmB,GACPC,EAAuB1B,mBAEzBM,EAAQH,GAAAQ,IACVL,EAAKH,GAAKQ,EAAOR,GAEnB,IAAA,MAAAM,KAAAY,EAAA,CAEK,MAAAM,EAAYrB,IAAcG,EAAAN,EACvBwB,EAAYrB,EAAKH,EAAIM,EAAON,EAClC,IAAA,IAAea,EAAA,EAAOY,EAAKnB,EAAOoB,QAAChB,OAAAG,EAAAY,EAAAZ,IAAA,CAEnC,QAAoBY,EAAaF,WAC/B,IAAAI,IACIA,QAAoBC,GAEbA,EAAWJ,EAAGK,EAAAvC,EAAAwC,OAAAxB,EAAAO,GAElBe,EAEPD,GAIAJ,EAAAQ,KAAA,CAEAR,GAAAA,GAAQQ,OAAKJ,EAAA3B,GAAA2B,EAAA3B,EAAAwB,GAAAlB,EAAAN,EACXA,GAAIgC,GAAGC,OAAON,EAAO3B,GAAK2B,EAAO3B,EAAIwB,GAAalB,EAAON,EACzD0B,MAAOO,GAAMA,SAAaN,OAAOD,QAAiBpB,EAAM4B,MAExDA,OAAOF,EACPG,QACAtB,UAEF,CACF,CACF,MAAAuB,EAAA,CAEAT,YACEA,SAAY,EACZU,SAAc,EACdC,MAAAA,EACAJ,MAAO,GACF,EAAIlC,EAAG,QACb,MAAA2B,KAAAJ,EAAA,CAEI,MAAAW,EAAYP,QACTO,EAAKP,EAAS3B,IAAMA,EACpBuC,EAAKZ,EAAO3B,EAAIG,EAAKH,EACrBwC,EAAWC,MAAKtC,EAAKuB,GAC3B,IAAAW,EAAcC,GAAWJ,EAIzBA,IAAAQ,KAAAN,EAAAC,SAAAD,EAAAF,QAAAQ,MACIR,GAAUQ,GAEdN,EAAAT,UAAAU,EAKMD,EAAAC,SAAAH,IAAAQ,IAEEJ,EAAAJ,EAAAE,EAAAE,SAAAF,EAAAF,MAEAA,IAAAQ,KAAAN,EAAAF,QAAAQ,KAEAJ,EAAAF,EAAAE,UAEFF,EAAAC,SAAAC,EAAAF,EAAAE,YACQF,EAAQT,OAAAA,EAEpBS,EAAQT,WACRS,EAAQE,MAAQJ,EAChBE,EAAQF,UACRE,EAAQC,MAAOrC,EAAGqC,EAClBD,EAAQO,MAAM3C,EAAIuC,EAEpB,CAQF7C,OAPA0C,EAAAC,UAEID,EAAAA,EAAQC,EAASV,OAAA3B,EACnBE,EAAOF,EAAIoC,EAAQT,OAAO3B,GAE5BN,EAAA0C,QAAAA,EAEaA,CACb,CACF,SAAAtC,UAAAC,GAESD,MAAAA,QACDN,GAAEA,EAAAA,YAER,OAFmCe,SAAAF,gBAAAN,EAAAL,MAAAE,QAAAY,OAAA,KAAA,KAAA,CAAAhB,oBACYO,aAAUH,EAAcG,EAAaT,YAAgB8B,SAAGC,KAGvG,CACF,MAAAuB,SAAA,CAEAV,UACEA,QAAe,KACfX,YACAjB,kBAAY,EACZT,OAAAA,KACAW,eAAY,KACZC,SAAAA,EACAoC,SAAS,GAEVC,KAAA,CACDzD,YACEA,QACA4B,mBAEF,IAAC8B,OAAAC,aAAAF,KAAA,eAEDC,kBAAgCD"}