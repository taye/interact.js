{"version":3,"file":"plugin.prod.js","sources":["plugin.ts"],"sourcesContent":["import type { Interactable } from '@interactjs/core/Interactable'\nimport type { InteractEvent, EventPhase } from '@interactjs/core/InteractEvent'\nimport type { Interaction, DoPhaseArg } from '@interactjs/core/Interaction'\nimport type { PerActionDefaults } from '@interactjs/core/options'\nimport type { Scope, Plugin } from '@interactjs/core/scope'\nimport type { Rect, PointerType, ListenersArg, OrBoolean } from '@interactjs/core/types'\nimport is from '@interactjs/utils/is'\nimport * as pointerUtils from '@interactjs/utils/pointerUtils'\n\ndeclare module '@interactjs/core/Interaction' {\n  interface Interaction {\n    gesture?: {\n      angle: number // angle from first to second touch\n      distance: number\n      scale: number // gesture.distance / gesture.startDistance\n      startAngle: number // angle of line joining two touches\n      startDistance: number // distance between two touches of touchStart\n    }\n  }\n}\n\ndeclare module '@interactjs/core/Interactable' {\n  interface Interactable {\n    gesturable(options: Partial<OrBoolean<GesturableOptions>> | boolean): this\n    gesturable(): GesturableOptions\n    /**\n     * ```js\n     * interact(element).gesturable({\n     *     onstart: function (event) {},\n     *     onmove : function (event) {},\n     *     onend  : function (event) {},\n     *\n     *     // limit multiple gestures.\n     *     // See the explanation in {@link Interactable.draggable} example\n     *     max: Infinity,\n     *     maxPerElement: 1,\n     * })\n     *\n     * var isGestureable = interact(element).gesturable()\n     * ```\n     *\n     * Gets or sets whether multitouch gestures can be performed on the target\n     *\n     * @param options - true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n     * @returns A boolean indicating if this can be the target of gesture events, or this Interactable\n     */\n    gesturable(options?: Partial<OrBoolean<GesturableOptions>> | boolean): this | GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/options' {\n  interface ActionDefaults {\n    gesture: GesturableOptions\n  }\n}\n\ndeclare module '@interactjs/core/types' {\n  interface ActionMap {\n    gesture?: typeof gesture\n  }\n}\n\nexport interface GesturableOptions extends PerActionDefaults {\n  onstart?: ListenersArg\n  onmove?: ListenersArg\n  onend?: ListenersArg\n}\n\nexport interface GestureEvent extends InteractEvent<'gesture'> {\n  distance: number\n  angle: number\n  da: number // angle change\n  scale: number // ratio of distance start to current event\n  ds: number // scale change\n  box: Rect // enclosing box of all points\n  touches: PointerType[]\n}\n\nexport interface GestureSignalArg extends DoPhaseArg<'gesture', EventPhase> {\n  iEvent: GestureEvent\n  interaction: Interaction<'gesture'>\n}\n\nfunction install(scope: Scope) {\n  const { actions, Interactable, defaults } = scope\n\n  Interactable.prototype.gesturable = function (\n    this: InstanceType<typeof Interactable>,\n    options: GesturableOptions | boolean,\n  ) {\n    if (is.object(options)) {\n      this.options.gesture.enabled = options.enabled !== false\n      this.setPerAction('gesture', options)\n      this.setOnEvents('gesture', options)\n\n      return this\n    }\n\n    if (is.bool(options)) {\n      this.options.gesture.enabled = options\n\n      return this\n    }\n\n    return this.options.gesture as GesturableOptions\n  } as Interactable['gesturable']\n\n  actions.map.gesture = gesture\n  actions.methodDict.gesture = 'gesturable'\n\n  defaults.actions.gesture = gesture.defaults\n}\n\nfunction updateGestureProps({ interaction, iEvent, phase }: GestureSignalArg) {\n  if (interaction.prepared.name !== 'gesture') return\n\n  const pointers = interaction.pointers.map((p) => p.pointer)\n  const starting = phase === 'start'\n  const ending = phase === 'end'\n  const deltaSource = interaction.interactable.options.deltaSource\n\n  iEvent.touches = [pointers[0], pointers[1]]\n\n  if (starting) {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = 1\n    iEvent.ds = 0\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n    iEvent.da = 0\n\n    interaction.gesture.startDistance = iEvent.distance\n    interaction.gesture.startAngle = iEvent.angle\n  } else if (ending || interaction.pointers.length < 2) {\n    const prevEvent = interaction.prevEvent as GestureEvent\n\n    iEvent.distance = prevEvent.distance\n    iEvent.box = prevEvent.box\n    iEvent.scale = prevEvent.scale\n    iEvent.ds = 0\n    iEvent.angle = prevEvent.angle\n    iEvent.da = 0\n  } else {\n    iEvent.distance = pointerUtils.touchDistance(pointers, deltaSource)\n    iEvent.box = pointerUtils.touchBBox(pointers)\n    iEvent.scale = iEvent.distance / interaction.gesture.startDistance\n    iEvent.angle = pointerUtils.touchAngle(pointers, deltaSource)\n\n    iEvent.ds = iEvent.scale - interaction.gesture.scale\n    iEvent.da = iEvent.angle - interaction.gesture.angle\n  }\n\n  interaction.gesture.distance = iEvent.distance\n  interaction.gesture.angle = iEvent.angle\n\n  if (is.number(iEvent.scale) && iEvent.scale !== Infinity && !isNaN(iEvent.scale)) {\n    interaction.gesture.scale = iEvent.scale\n  }\n}\n\nconst gesture: Plugin = {\n  id: 'actions/gesture',\n  before: ['actions/drag', 'actions/resize'],\n  install,\n  listeners: {\n    'interactions:action-start': updateGestureProps,\n    'interactions:action-move': updateGestureProps,\n    'interactions:action-end': updateGestureProps,\n\n    'interactions:new': ({ interaction }) => {\n      interaction.gesture = {\n        angle: 0,\n        distance: 0,\n        scale: 1,\n        startAngle: 0,\n        startDistance: 0,\n      }\n    },\n\n    'auto-start:check': (arg) => {\n      if (arg.interaction.pointers.length < 2) {\n        return undefined\n      }\n\n      const gestureOptions = arg.interactable.options.gesture\n\n      if (!(gestureOptions && gestureOptions.enabled)) {\n        return undefined\n      }\n\n      arg.action = { name: 'gesture' }\n\n      return false\n    },\n  },\n\n  defaults: {},\n\n  getCursor() {\n    return ''\n  },\n\n  filterEventType: (type: string) => type.search('gesture') === 0,\n}\n\nexport default gesture\n"],"names":["install","actions","Interactable","defaults","prototype","gesturable","options","object","enabled","this","setPerAction","is","bool","gesture","map","methodDict","updateGestureProps","_ref","interaction","iEvent","phase","prepared","name","pointers","p","pointer","starting","ending","interactable","deltaSource","touches","pointerUtils","touchDistance","distance","touchBBox","box","scale","ds","touchAngle","angle","startDistance","prevEvent","Infinity","isNaN","id","before","_ref2","startAngle","arg","length","gestureOptions","action","getCursor","type","search"],"mappings":";;yHAmFSA,MAAAA,QACDC,EAAAC,aAAED,EAAOE,SAAED,GAAcC,EAAUD,EAAQE,UAAAC,WAAA,SAAAC,GAEjDJ,OAAAA,GAAAA,OAAsBI,SAIbC,QAAOD,QAAUE,SAAA,IAAAF,EAAAE,QACtBC,KAAKH,aAAe,UAAQA,GAC5BG,KAAKC,YAAY,UAAYJ,GACbG,MAGlBE,GAAAC,KAAAN,SAEOM,QAAKN,QAAUE,QAAAF,EACRG,MAGdA,KAAAH,QAAAO,OAEA,IAC6BC,IAAAD,QAAAA,QAE/BZ,EAAQa,WAAWD,QAAU,aAC7BZ,EAAQc,QAAAA,QAAkBF,gBAE1BV,CACF,SAAAa,mBAAAC,GAESD,IAAAA,YAAmBE,EAAAC,OAAED,EAAWE,MAAED,GAAQC,EAAyB,GAAA,YAAAH,EAAAI,SAAAC,KAAA,OAC1E,QAAgBD,EAAaE,SAAcT,KAAAU,GAAEA,EAAAC,UAEvCF,EAAWL,UAAAA,EACXQ,EAAgB,QAARN,EACRO,EAAcT,EAAUU,aAAAtB,QAAAuB,YAG9BV,GAFAA,EAAiBW,QAAA,CAAAP,EAAc,GAAAA,MAEzBG,EAENP,WAAcY,aAAAC,cAAAT,EAAAM,GACZV,EAAOc,IAAQF,aAAeG,UAAcX,GAC5CJ,EAAOgB,MAAMJ,EACbZ,EAAOiB,GAAK,EACZjB,EAAOkB,MAAMN,aAAAO,WAAAf,EAAAM,GACbV,EAAOoB,GAAK,EACZpB,EAAYN,QAAC2B,cAAArB,EAAAc,SAEbf,EAAYL,QAAQ2B,WAAarB,EAAGA,WACpCD,GAAAA,GAAmBA,EAAcC,SAAOoB,OAAK,EAAA,CAC9C,MAAUZ,EAAUT,EAAWuB,UAC9BtB,EAAec,SAAGf,EAAWe,SAE7Bd,EAAOc,IAAAA,EAAoBE,IAC3BhB,EAAOgB,MAAeM,QACtBtB,EAAOiB,GAAK,EACZjB,EAAOkB,MAAMI,EAAAF,MACbpB,EAAOoB,GAAK,OAEPpB,EAAAc,SAAAF,aAAAC,cAAAT,EAAAM,GACLV,EAAOc,IAAQF,aAAeG,UAAcX,GAC5CJ,EAAOgB,MAAMJ,EAAAA,SAAsBb,EAAUL,QAAA2B,cAC7CrB,EAAOiB,MAAQjB,aAAemB,WAAcf,EAAQM,GACpDV,EAAOoB,GAAKpB,EAAeiB,MAAAlB,EAAYK,QAAQa,MAE/CjB,EAAOkB,GAAKlB,EAAOiB,MAAQlB,EAAYL,QAAQuB,MAEjDlB,EAAAL,QAAAoB,SAAAd,EAAAc,SAEAf,EAAYL,QAAQoB,MAAQd,EAAGA,MAC/BD,GAAAA,OAAmBC,UAASA,EAAOoB,QAAKG,MAAAC,MAAAxB,EAAAiB,SAExClB,EAAcC,QAAYiB,MAAKjB,EAAMiB,MAErC,CACF,MAAAvB,QAAA,CAEA+B,GAAM/B,kBACJ+B,OAAqB,CAAA,eAAA,kBACrBC,gBACA7C,UAAO,6BACIgB,mBACT,8CACA,6CACA,mBAAA8B,GAEA,IAAA5B,YAAqBA,GAAEA,EAAaA,EAAAL,QAAA,CAClCK,MAAAA,EACEqB,SAAQ,EACRN,MAAAA,EACAG,WAAQ,EACRW,cAAa,EACbP,EAEH,kBAeC,CAfDQ,GAED,GAAAA,EAAA9B,YAAqB8B,SAAQC,OAAA,EAC3B,OAEA,MAAAC,EAAAF,EAAApB,aAAAtB,QAAAO,QAEA,OAAMqC,GAAoBA,EAAa1C,SAIvCwC,EAAAG,OAAA,CAEAH,KAAIG,YAA4B,QANhC,CAMgC,GAInChD,SAAA,CAAA,EAEDA,cAESiD,GAER,eAAA,CAAAC,GAAAA,OAAA,IAAAA,EAAAC,OAAA,oBAGHzC"}